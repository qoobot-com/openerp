# QooERP Gateway 模块 - 技术设计文档

## 1. 技术选型

### 1.1 核心技术栈

| 技术组件 | 版本 | 用途 |
|---------|------|------|
| Spring Cloud Gateway | 2023.x | API网关框架 |
| Spring Boot | 3.x | 应用框架 |
| Nacos | 2.x | 服务发现和配置中心 |
| Redis | 7.x | 限流存储 |
| Sentinel | 1.8.x | 限流熔断 |
| Zipkin/Sleuth | 3.x | 链路追踪 |
| Netty | 4.1.x | 异步网络框架 |

### 1.2 依赖配置

```xml
<dependencies>
    <!-- Spring Cloud Gateway -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-gateway</artifactId>
    </dependency>
    
    <!-- Nacos 服务发现 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    
    <!-- Nacos 配置中心 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    
    <!-- Redis -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
    
    <!-- Sentinel 限流熔断 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-sentinel-gateway</artifactId>
    </dependency>
    
    <!-- 链路追踪 -->
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-starter-sleuth</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.cloud</groupId>
        <artifactId>spring-cloud-sleuth-zipkin</artifactId>
    </dependency>
    
    <!-- 公共模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-api</artifactId>
    </dependency>
</dependencies>
```

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────────────┐
│                        客户端层                                 │
│                     Web / Mobile / App                          │
└────────────────────────────┬────────────────────────────────────┘
                             │
                    ┌────────▼────────┐
                    │   DNS/CDN      │
                    └────────┬────────┘
                             │
                    ┌────────▼────────┐
                    │   负载均衡       │
                    │   (Nginx/LVS)   │
                    └────────┬────────┘
                             │
                    ┌────────▼────────────────────────────────────┐
                    │         Spring Cloud Gateway                │
                    │  ┌─────────────────────────────────────────┐  │
                    │  │            全局过滤器层                  │  │
                    │  │  - AuthFilter      (认证)                │  │
                    │  │  - PermissionFilter (鉴权)               │  │
                    │  │  - LogFilter       (日志)                │  │
                    │  │  - TraceFilter     (追踪)                │  │
                    │  │  - RateLimitFilter (限流)               │  │
                    │  └─────────────────────┬───────────────────┘  │
                    │  ┌─────────────────────▼───────────────────┐  │
                    │  │            路由匹配层                     │  │
                    │  │  - Predicate 断言匹配                     │  │
                    │  │  - Route  路由选择                        │  │
                    │  └─────────────────────┬───────────────────┘  │
                    │  ┌─────────────────────▼───────────────────┐  │
                    │  │            路由过滤器层                   │  │
                    │  │  - StripPrefix     (路径截取)             │  │
                    │  │  - RewritePath     (路径重写)             │  │
                    │  │  - AddRequestHeader (请求头添加)          │  │
                    │  └─────────────────────┬───────────────────┘  │
                    │  ┌─────────────────────▼───────────────────┐  │
                    │  │            负载均衡层                     │  │
                    │  │  - Ribbon 负载均衡                        │  │
                    │  └─────────────────────┬───────────────────┘  │
                    │  ┌─────────────────────▼───────────────────┐  │
                    │  │            熔断降级层                     │  │
                    │  │  - Sentinel 熔断降级                      │  │
                    │  └─────────────────────┬───────────────────┘  │
                    │  ┌─────────────────────▼───────────────────┐  │
                    │  │            HTTP客户端层                   │  │
                    │  │  - Netty HttpClient                     │  │
                    │  └──────────────────────────────────────────┘  │
                    └─────────────────────┬──────────────────────────┘
                                          │
          ┌───────────────────────────────┼───────────────────────────┐
          │                               │                           │
     ┌────▼─────┐                  ┌─────▼─────┐               ┌─────▼─────┐
     │ 认证服务  │                  │ 权限服务    │               │ 用户服务    │
     │  Auth    │                  │ Permission │               │   User    │
     └──────────┘                  └───────────┘               └───────────┘
          │                               │                           │
     ┌────▼─────┐                  ┌─────▼─────┐               ┌─────▼─────┐
     │ 系统服务  │                  │ 组织服务    │               │ 业务服务    │
     │ System   │                  │Organization│               │   ...     │
     └──────────┘                  └───────────┘               └───────────┘
                                          │
                             ┌────────────┼────────────┐
                             │            │            │
                        ┌────▼────┐ ┌────▼────┐  ┌────▼────┐
                        │  Redis  │ │  Nacos  │  │ Sentinel│
                        │ (限流)   │ │(服务发现)│  │ (监控)   │
                        └─────────┘ └─────────┘  └─────────┘
```

### 2.2 工作流程

```
1. 客户端发送请求到Gateway
   ↓
2. 全局过滤器前置处理
   - AuthFilter: 认证校验
   - PermissionFilter: 权限校验
   - LogFilter: 记录请求开始时间
   ↓
3. 路由匹配
   - 根据断言匹配目标路由
   ↓
4. 路由过滤器处理
   - StripPrefix: 截取路径前缀
   - AddRequestHeader: 添加用户信息头
   ↓
5. 负载均衡
   - Ribbon选择目标实例
   ↓
6. 熔断降级检查
   - Sentinel检查资源状态
   ↓
7. 发送请求到目标服务
   ↓
8. 全局过滤器后置处理
   - LogFilter: 记录响应时间
   - TraceFilter: 上报链路追踪数据
   ↓
9. 返回响应给客户端
```

## 3. 核心功能实现

### 3.1 动态路由

#### 动态路由配置服务

```java
@Service
public class DynamicRouteService {
    
    @Autowired
    private RouteDefinitionWriter routeDefinitionWriter;
    
    @Autowired
    private RouteDefinitionLocator routeDefinitionLocator;
    
    @Autowired
    private NacosConfigProperties nacosConfigProperties;
    
    /**
     * 从Nacos加载路由配置
     */
    @PostConstruct
    public void loadRoutesFromNacos() {
        try {
            ConfigService configService = NacosFactory.createConfigService(
                nacosConfigProperties.getServerAddr());
            
            String content = configService.getConfig(
                "gateway-routes.yml", 
                nacosConfigProperties.getGroup(), 
                5000
            );
            
            if (StringUtils.isNotBlank(content)) {
                List<RouteDefinition> routes = parseRoutes(content);
                routes.forEach(route -> {
                    routeDefinitionWriter.save(Mono.just(route)).subscribe();
                });
            }
        } catch (NacosException e) {
            log.error("从Nacos加载路由配置失败", e);
        }
    }
    
    /**
     * 监听Nacos配置变化
     */
    public void listenRouteConfigChange() {
        try {
            ConfigService configService = NacosFactory.createConfigService(
                nacosConfigProperties.getServerAddr());
            
            configService.addListener(
                "gateway-routes.yml", 
                nacosConfigProperties.getGroup(), 
                new Listener() {
                    @Override
                    public void receiveConfigInfo(String configInfo) {
                        log.info("收到路由配置变更: {}", configInfo);
                        
                        // 清除所有现有路由
                        routeDefinitionLocator.getRouteDefinitions()
                            .flatMap(route -> routeDefinitionWriter.delete(Mono.just(route.getId())))
                            .collectList()
                            .block();
                        
                        // 加载新路由
                        List<RouteDefinition> routes = parseRoutes(configInfo);
                        routes.forEach(route -> {
                            routeDefinitionWriter.save(Mono.just(route)).subscribe();
                        });
                    }
                    
                    @Override
                    public Executor getExecutor() {
                        return null;
                    }
                }
            );
        } catch (NacosException e) {
            log.error("监听路由配置变化失败", e);
        }
    }
}
```

### 3.2 分布式限流

#### 基于Redis的限流实现

```java
@Component
public class RedisRateLimiter {
    
    @Autowired
    private RedisTemplate<String, String> redisTemplate;
    
    /**
     * 尝试获取令牌
     */
    public boolean tryAcquire(String key, long replenishRate, long burstCapacity) {
        // 令牌桶算法
        String script = "local key = KEYS[1]\n" +
            "local rate = tonumber(ARGV[1])\n" +
            "local capacity = tonumber(ARGV[2])\n" +
            "local now = tonumber(ARGV[3])\n" +
            "local requested = tonumber(ARGV[4])\n" +
            "local ttl = tonumber(ARGV[5])\n" +
            "\n" +
            "local current = redis.call('hmget', key, 'tokens', 'last_refill_time')\n" +
            "local tokens = tonumber(current[1])\n" +
            "local last_refill_time = tonumber(current[2])\n" +
            "\n" +
            "if tokens == nil then\n" +
            "    tokens = capacity\n" +
            "    last_refill_time = now\n" +
            "end\n" +
            "\n" +
            "local delta = math.max(0, now - last_refill_time)\n" +
            "local filled_tokens = math.min(capacity, tokens + (delta * rate / 1000))\n" +
            "\n" +
            "if filled_tokens < requested then\n" +
            "    redis.call('hmset', key, 'tokens', filled_tokens, 'last_refill_time', now)\n" +
            "    redis.call('expire', key, ttl)\n" +
            "    return 0\n" +
            "else\n" +
            "local new_tokens = filled_tokens - requested\n" +
            "    redis.call('hmset', key, 'tokens', new_tokens, 'last_refill_time', now)\n" +
            "    redis.call('expire', key, ttl)\n" +
            "    return 1\n" +
            "end";
        
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(script);
        redisScript.setResultType(Long.class);
        
        Long result = redisTemplate.execute(
            redisScript,
            Collections.singletonList(key),
            String.valueOf(replenishRate),
            String.valueOf(burstCapacity),
            String.valueOf(System.currentTimeMillis()),
            String.valueOf(1),
            String.valueOf(60)
        );
        
        return result != null && result == 1;
    }
}
```

### 3.3 链路追踪

#### Sleuth配置

```yaml
spring:
  sleuth:
    zipkin:
      base-url: http://localhost:9411
      sender-type: rabbit
    sleuth:
      web:
        client:
          enabled: true
      sampling:
        probability: 1.0  # 100%采样率
      propagation:
        type: b3  # B3传播格式
    zipkin:
      rabbitmq:
        queue: zipkin
        addresses: localhost:5672
```

#### TraceId传递

```java
@Component
@Order(-80)
public class TraceFilter implements GlobalFilter {
    
    private static final String TRACE_ID_HEADER = "X-Trace-Id";
    private static final String SPAN_ID_HEADER = "X-Span-Id";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        
        // 从MDC获取TraceId
        String traceId = MDC.get("traceId");
        if (StringUtils.isBlank(traceId)) {
            traceId = generateTraceId();
            MDC.put("traceId", traceId);
        }
        
        // 将TraceId添加到请求头
        ServerHttpRequest modifiedRequest = request.mutate()
            .header(TRACE_ID_HEADER, traceId)
            .header(SPAN_ID_HEADER, generateSpanId())
            .build();
        
        return chain.filter(exchange.mutate().request(modifiedRequest).build())
            .doFinally(signalType -> {
                MDC.remove("traceId");
            });
    }
    
    private String generateTraceId() {
        return UUID.randomUUID().toString().replace("-", "");
    }
    
    private String generateSpanId() {
        return UUID.randomUUID().toString().replace("-", "").substring(0, 16);
    }
}
```

### 3.4 熔断降级

#### Sentinel配置

```java
@Configuration
public class SentinelConfig {
    
    @PostConstruct
    public void initGatewayRules() {
        Set<GatewayFlowRule> rules = new HashSet<>();
        
        // 认证服务限流规则
        rules.add(new GatewayFlowRule("qooerp-auth")
            .setCount(100)  // 每秒100个请求
            .setIntervalSec(1)
            .setBurst(200)  // 突发200个
            .setControlBehavior(RuleConstant.CONTROL_BEHAVIOR_RATE_LIMITER)  // 匀速排队
            .setGrade(RuleConstant.FLOW_GRADE_QPS)  // QPS限流
        );
        
        // 用户服务限流规则
        rules.add(new GatewayFlowRule("qooerp-user")
            .setCount(200)
            .setIntervalSec(1)
            .setBurst(400)
        );
        
        // 系统服务限流规则
        rules.add(new GatewayFlowRule("qooerp-system")
            .setCount(150)
            .setIntervalSec(1)
            .setBurst(300)
        );
        
        GatewayRuleManager.loadRules(rules);
        
        // 设置降级回调
        GatewayCallbackManager.setBlockHandler(new BlockRequestHandler() {
            @Override
            public Mono<ServerResponse> handleRequest(ServerWebExchange exchange, 
                                                     Throwable ex) {
                Map<String, Object> result = new HashMap<>();
                
                if (ex instanceof FlowException) {
                    result.put("code", 429);
                    result.put("message", "访问过于频繁，请稍后再试");
                } else if (ex instanceof DegradeException) {
                    result.put("code", 503);
                    result.put("message", "服务暂时不可用，请稍后再试");
                } else {
                    result.put("code", 500);
                    result.put("message", "系统繁忙，请稍后再试");
                }
                
                result.put("timestamp", System.currentTimeMillis());
                
                return ServerResponse.status(HttpStatus.OK)
                    .contentType(MediaType.APPLICATION_JSON)
                    .body(BodyInserters.fromValue(result));
            }
        });
    }
}
```

## 4. 性能优化

### 4.1 连接池优化

```yaml
spring:
  cloud:
    gateway:
      httpclient:
        connect-timeout: 1000  # 连接超时时间（毫秒）
        response-timeout: 5s   # 响应超时时间
        pool:
          type: elastic      # 弹性连接池
          max-connections: 1000  # 最大连接数
          max-idle-time: 10s     # 最大空闲时间
          max-life-time: 30s     # 最大存活时间
          acquire-timeout: 30000  # 获取连接超时时间
```

### 4.2 路由缓存

```java
@Component
public class RouteCacheConfig {
    
    @Autowired
    private CaffeineCacheManager cacheManager;
    
    @Bean
    public CaffeineCacheManager cacheManager() {
        CaffeineCacheManager manager = new CaffeineCacheManager("routeCache");
        manager.setCaffeine(Caffeine.newBuilder()
            .expireAfterWrite(10, TimeUnit.MINUTES)  // 10分钟过期
            .maximumSize(1000)  // 最多缓存1000个路由
        );
        return manager;
    }
}
```

### 4.3 请求压缩

```yaml
server:
  compression:
    enabled: true
    mime-types: application/json,application/xml,text/html,text/xml,text/plain
```

## 5. 监控和告警

### 5.1 Metrics监控

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,gateway,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
  endpoint:
    health:
      show-details: always
```

### 5.2 日志采集

```xml
<appender name="LOKI" class="com.github.loki4j.logback.Loki4jAppender">
    <http>
        <url>http://localhost:3100/loki/api/v1/push</url>
    </http>
    <format>
        <label>
            <pattern>app=${spring.application.name},env=${spring.profiles.active},host=${HOSTNAME}</pattern>
            <readMarkers>true</readMarkers>
        </label>
        <message>
            <pattern>l=%level t=%thread d=%d{yyyy-MM-dd HH:mm:ss.SSS} c=%logger{36} m=%msg%n</pattern>
        </message>
    </format>
</appender>
```

### 5.3 告警规则

```yaml
# Prometheus告警规则
groups:
- name: gateway_alerts
  rules:
  - alert: GatewayHighErrorRate
    expr: rate(gateway_requests_total{status=~"5.."}[5m]) > 0.05
    for: 5m
    labels:
      severity: critical
    annotations:
      summary: "网关错误率过高"
      description: "网关 {{ $labels.instance }} 5分钟内5xx错误率超过5%"
  
  - alert: GatewayHighLatency
    expr: histogram_quantile(0.95, rate(gateway_request_duration_seconds_bucket[5m])) > 1
    for: 5m
    labels:
      severity: warning
    annotations:
      summary: "网关延迟过高"
      description: "网关 {{ $labels.instance }} 5分钟内P95延迟超过1秒"
```

## 6. 部署配置

### 6.1 application.yml

```yaml
server:
  port: 8080

spring:
  application:
    name: qooerp-gateway
  profiles:
    active: dev
  
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_ADDR:localhost:8848}
        namespace: qooerp
        metadata:
          version: 1.0.0
      config:
        server-addr: ${NACOS_ADDR:localhost:8848}
        namespace: qooerp
        group-id: GATEWAY_GROUP
        file-extension: yml
        shared-configs:
          - data-id: gateway-common.yml
            group-id: COMMON_GROUP
            refresh: true
    
    gateway:
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
      
      # 全局跨域配置
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOriginPatterns: "*"
            allowedMethods: "*"
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600
      
      # 默认过滤器
      default-filters:
        - name: Retry
          args:
            retries: 3
            statuses: BAD_GATEWAY,SERVICE_UNAVAILABLE
            methods: GET,POST
            backoff:
              firstBackoff: 10ms
              maxBackoff: 50ms
              factor: 2
              basedOnPreviousValue: false
      
      # HTTP客户端配置
      httpclient:
        connect-timeout: 1000
        response-timeout: 5s
        pool:
          type: elastic
          max-connections: 1000
          max-idle-time: 10s
          max-life-time: 30s
          acquire-timeout: 30000
  
  # Redis配置
  redis:
    host: ${REDIS_HOST:localhost}
    port: ${REDIS_PORT:6379}
    database: 0
    password: ${REDIS_PASSWORD:}
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
        min-idle: 0
        max-wait: -1ms

# Sentinel配置
spring:
  cloud:
    sentinel:
      transport:
        dashboard: ${SENTINEL_DASHBOARD:localhost:8848}
        port: 8719
      eager: true
      datasource:
        ds:
          nacos:
            server-addr: ${NACOS_ADDR:localhost:8848}
            namespace: qooerp
            data-id: gateway-sentinel-rules
            group-id: DEFAULT_GROUP
            rule-type: flow

# 链路追踪配置
spring:
  sleuth:
    zipkin:
      base-url: ${ZIPKIN_URL:http://localhost:9411}
      sender-type: rabbit
    sleuth:
      web:
        client:
          enabled: true
      sampling:
        probability: 1.0
      propagation:
        type: b3

# 日志配置
logging:
  level:
    root: INFO
    com.qoobot.qooerp.gateway: DEBUG
    org.springframework.cloud.gateway: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%X{traceId}] %logger{36} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%X{traceId}] %logger{36} - %msg%n"
  file:
    name: /data/qooerp/logs/gateway.log
    max-size: 100MB
    max-history: 30

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,gateway,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
      env: ${spring.profiles.active}
```

### 6.2 环境变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| SERVER_PORT | 服务端口 | 8080 |
| NACOS_ADDR | Nacos地址 | localhost:8848 |
| REDIS_HOST | Redis主机 | localhost |
| REDIS_PORT | Redis端口 | 6379 |
| REDIS_PASSWORD | Redis密码 | - |
| SENTINEL_DASHBOARD | Sentinel控制台 | localhost:8848 |
| ZIPKIN_URL | Zipkin地址 | http://localhost:9411 |
| JAVA_OPTS | JVM参数 | -Xms512m -Xmx1024m |

### 6.3 Docker部署

```dockerfile
FROM openjdk:17-jdk-slim

WORKDIR /app

COPY qooerp-gateway/target/qooerp-gateway-1.0.0.jar app.jar

ENV JAVA_OPTS="-Xms512m -Xmx1024m"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

```yaml
# docker-compose.yml
version: '3.8'
services:
  gateway:
    image: qooerp/gateway:1.0.0
    ports:
      - "8080:8080"
    environment:
      - SERVER_PORT=8080
      - NACOS_ADDR=nacos:8848
      - REDIS_HOST=redis
      - REDIS_PORT=6379
      - SENTINEL_DASHBOARD=sentinel:8848
    depends_on:
      - nacos
      - redis
    networks:
      - qooerp-network

networks:
  qooerp-network:
    external: true
```

## 7. 版本历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0.0 | 2025-01-17 | 初始版本 | Auto |
