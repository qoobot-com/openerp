# QooERP 报表与分析模块 - 技术设计文档

> 模块名称: qooerp-report
> 模块版本: v1.0
> 创建日期: 20xx-xx-xx
> 作者: Auto
> **数据库**: PostgreSQL 15+

---

## 一、技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Spring Boot | 3.2.x | 核心框架 |
| Spring Cloud | 2023.x | 微服务框架 |
| MyBatis-Plus | 3.5.x | ORM框架 |
| PostgreSQL | 15+ | 数据库 |
| ECharts | 5.x | 图表库 |
| Redis | 7.x | 缓存 |
| Apache POI | 5.x | Excel导出 |
| iText | 7.x | PDF导出 |
| Netty | 4.x | WebSocket服务 |

---

## 二、架构设计

### 2.1 分层架构

```
┌─────────────────────────────────────────┐
│     Presentation Layer (Controller)    │
│  - ReportController                     │
│  - DatasourceController                 │
│  - DashboardController                 │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│     Business Layer (Service)             │
│  - ReportService                        │
│  - DatasourceService                    │
│  - DashboardService                     │
│  - SubscriptionService                  │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│     Data Access Layer (Mapper)          │
│  - ReportMapper                         │
│  - DatasourceMapper                     │
│  - DashboardMapper                      │
└─────────────────────────────────────────┘
                    ↓
┌─────────────────────────────────────────┐
│  Infrastructure Layer                   │
│  - PostgreSQL Database                  │
│  - Redis Cache                          │
│  - WebSocket Server                     │
└─────────────────────────────────────────┘
```

### 2.2 核心模块

| 模块 | 说明 |
|------|------|
| report | 报表管理模块 |
| datasource | 数据源管理模块 |
| config | 报表配置模块 |
| dashboard | 仪表盘管理模块 |
| subscription | 订阅管理模块 |
| history | 历史记录模块 |
| export | 导出服务模块 |
| cache | 缓存服务模块 |

---

## 三、核心功能实现

### 3.1 报表数据查询

```java
@Service
public class ReportDataQueryService {
    
    @Autowired
    private ReportDatasourceMapper datasourceMapper;
    
    @Autowired
    private DynamicQueryExecutor queryExecutor;
    
    public Map<String, Object> queryReportData(Long reportId, ReportQueryDTO query) {
        // 1. 获取数据源配置
        ReportDatasource datasource = datasourceMapper.selectOne(
            new LambdaQueryWrapper<ReportDatasource>()
                .eq(ReportDatasource::getReportId, reportId)
        );
        
        // 2. 检查缓存
        String cacheKey = buildCacheKey(reportId, query);
        Map<String, Object> cachedData = cacheService.get(cacheKey);
        if (cachedData != null) {
            return cachedData;
        }
        
        // 3. 动态SQL查询
        Map<String, Object> data = queryExecutor.execute(
            datasource.getDatasourceType(),
            datasource.getConnectionConfig(),
            datasource.getSqlQuery(),
            query.getFilters()
        );
        
        // 4. 缓存结果
        cacheService.set(cacheKey, data, datasource.getCacheDuration());
        
        return data;
    }
}
```

### 3.2 动态SQL执行器

```java
@Component
public class DynamicQueryExecutor {
    
    public Map<String, Object> execute(String type, String config, 
            String sql, Map<String, Object> params) {
        switch (type) {
            case "mysql":
                return executeMySQL(config, sql, params);
            case "postgresql":
                return executePostgreSQL(config, sql, params);
            case "api":
                return executeAPI(config, sql, params);
            default:
                throw new BusinessException("Unsupported datasource type");
        }
    }
    
    private Map<String, Object> executePostgreSQL(String config, 
            String sql, Map<String, Object> params) {
        // 解析连接配置
        DataSourceConfig dsConfig = JSON.parseObject(config, DataSourceConfig.class);
        
        // 动态创建数据源
        DataSource dataSource = createDataSource(dsConfig);
        
        // 执行查询
        JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);
        List<Map<String, Object>> data = jdbcTemplate.queryForList(sql, params);
        
        return Map.of(
            "columns", extractColumns(data),
            "rows", data
        );
    }
}
```

### 3.3 报表导出服务

```java
@Service
public class ReportExportService {
    
    public byte[] exportToExcel(Long reportId, ReportQueryDTO query) {
        // 1. 获取报表数据
        Map<String, Object> data = reportDataQueryService.queryReportData(reportId, query);
        
        // 2. 创建Excel工作簿
        Workbook workbook = new XSSFWorkbook();
        Sheet sheet = workbook.createSheet("Report");
        
        // 3. 写入表头
        List<String> columns = (List<String>) data.get("columns");
        Row headerRow = sheet.createRow(0);
        for (int i = 0; i < columns.size(); i++) {
            headerRow.createCell(i).setCellValue(columns.get(i));
        }
        
        // 4. 写入数据
        List<Map<String, Object>> rows = (List<Map<String, Object>>) data.get("rows");
        for (int i = 0; i < rows.size(); i++) {
            Row row = sheet.createRow(i + 1);
            Map<String, Object> rowData = rows.get(i);
            for (int j = 0; j < columns.size(); j++) {
                row.createCell(j).setCellValue(String.valueOf(rowData.get(columns.get(j))));
            }
        }
        
        // 5. 返回字节数组
        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
        workbook.write(outputStream);
        return outputStream.toByteArray();
    }
}
```

### 3.4 WebSocket实时推送

```java
@Component
public class ReportWebSocketHandler extends TextWebSocketHandler {
    
    private static final Map<Long, Set<WebSocketSession>> sessionMap = new ConcurrentHashMap<>();
    
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        Long dashboardId = (Long) session.getAttributes().get("dashboardId");
        sessionMap.computeIfAbsent(dashboardId, k -> ConcurrentHashMap.newKeySet()).add(session);
    }
    
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        Long dashboardId = (Long) session.getAttributes().get("dashboardId");
        Set<WebSocketSession> sessions = sessionMap.get(dashboardId);
        if (sessions != null) {
            sessions.remove(session);
        }
    }
    
    public void broadcastToDashboard(Long dashboardId, String message) {
        Set<WebSocketSession> sessions = sessionMap.get(dashboardId);
        if (sessions != null) {
            sessions.forEach(session -> {
                try {
                    session.sendMessage(new TextMessage(message));
                } catch (IOException e) {
                    log.error("WebSocket send error", e);
                }
            });
        }
    }
}
```

---

## 四、缓存策略

### 4.1 缓存层级

```
┌─────────────────────────────┐
│  L1: 本地缓存 (Caffeine)     │  - 报表元数据
│  - 过期时间: 30分钟          │  - 仪表盘配置
└─────────────────────────────┘
            ↓
┌─────────────────────────────┐
│  L2: 分布式缓存 (Redis)      │  - 报表查询结果
│  - 过期时间: 5-60分钟        │  - 聚合数据
└─────────────────────────────┘
```

### 4.2 缓存Key设计

| Key格式 | 说明 | 过期时间 |
|---------|------|----------|
| report:meta:{id} | 报表元数据 | 30分钟 |
| report:data:{id}:{hash} | 报表查询结果 | 可配置 |
| dashboard:meta:{id} | 仪表盘元数据 | 30分钟 |
| datasource:meta:{id} | 数据源配置 | 1小时 |

### 4.3 缓存更新策略

```java
@Component
public class ReportCacheManager {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @CacheEvict(value = "report", key = "#reportId")
    public void evictReportCache(Long reportId) {
        String pattern = "report:data:" + reportId + ":*";
        Set<String> keys = redisTemplate.keys(pattern);
        if (keys != null && !keys.isEmpty()) {
            redisTemplate.delete(keys);
        }
    }
    
    @CacheEvict(value = "dashboard", key = "#dashboardId")
    public void evictDashboardCache(Long dashboardId) {
        // 清除仪表盘相关缓存
    }
}
```

---

## 五、性能优化

### 5.1 查询优化

1. **SQL优化**
   - 使用索引优化查询
   - 避免全表扫描
   - 使用分页查询

2. **数据预聚合**
   - 定时任务预计算常用报表
   - 使用物化视图存储聚合结果

3. **懒加载**
   - 大数据量报表支持分块加载
   - 图表数据按需加载

### 5.2 并发处理

```java
@Service
public class AsyncReportService {
    
    @Async("reportTaskExecutor")
    public CompletableFuture<Map<String, Object>> queryReportAsync(
            Long reportId, ReportQueryDTO query) {
        return CompletableFuture.completedFuture(
            reportDataQueryService.queryReportData(reportId, query)
        );
    }
    
    @Async("reportTaskExecutor")
    public void exportReportAsync(Long reportId, ReportQueryDTO query, 
            String email) {
        byte[] data = reportExportService.exportToExcel(reportId, query);
        emailService.sendReport(email, "report.xlsx", data);
    }
}
```

---

## 六、安全设计

### 6.1 数据权限控制

```java
@Service
public class ReportPermissionService {
    
    public boolean checkReportAccess(Long userId, Long reportId) {
        Report report = reportMapper.selectById(reportId);
        
        // 系统报表所有人可访问
        if (report.getDashboardType() == 3) {
            return true;
        }
        
        // 公共报表需要检查部门权限
        if (report.getDashboardType() == 2) {
            return checkDepartmentAccess(userId, report.getDepartmentId());
        }
        
        // 个人报表仅创建者可访问
        return report.getCreatedBy().equals(userId);
    }
}
```

### 6.2 SQL注入防护

```java
@Component
public class SQLSanitizer {
    
    public String sanitizeSQL(String sql) {
        // 移除危险关键字
        String sanitized = sql.replaceAll("(?i)(DROP|DELETE|TRUNCATE|ALTER|CREATE)", "");
        
        // 参数化查询
        return sanitized;
    }
    
    public boolean validateSQL(String sql) {
        // 验证SQL语法
        try {
            new JdbcParser(sql).parse();
            return true;
        } catch (Exception e) {
            return false;
        }
    }
}
```

---

## 七、监控与告警

### 7.1 性能监控

```java
@Component
@Slf4j
public class ReportMetrics {
    
    private final MeterRegistry registry;
    private final Counter queryCounter;
    private final Timer queryTimer;
    
    public ReportMetrics(MeterRegistry registry) {
        this.registry = registry;
        this.queryCounter = Counter.builder("report.query.count")
            .description("Total report queries")
            .register(registry);
        this.queryTimer = Timer.builder("report.query.duration")
            .description("Report query duration")
            .register(registry);
    }
    
    public void recordQuery(String reportType, long duration) {
        queryCounter.increment(Tags.of("type", reportType));
        queryTimer.record(duration, TimeUnit.MILLISECONDS);
    }
}
```

### 7.2 异常告警

```java
@Component
@Slf4j
public class ReportAlertService {
    
    @EventListener
    public void handleReportError(ReportQueryErrorEvent event) {
        log.error("Report query error: reportId={}, error={}", 
            event.getReportId(), event.getError());
        
        // 发送告警通知
        if (event.getErrorCount() > 10) {
            alertService.sendAlert("Report query error threshold exceeded");
        }
    }
}
```

---

## 八、部署配置

### 8.1 应用配置

```yaml
server:
  port: 8096
  servlet:
    context-path: /api/report

spring:
  application:
    name: qooerp-report
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://localhost:5432/qooerp_report
    username: qooerp_report
    password: qooerp_report_2026
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
  redis:
    host: localhost
    port: 6379
    database: 3
    timeout: 3000

mybatis-plus:
  mapper-locations: classpath*:/mapper/**/*.xml
  type-aliases-package: com.qoobot.qooerp.report.entity
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: false

# 线程池配置
async:
  executor:
    core-pool-size: 5
    max-pool-size: 20
    queue-capacity: 100
    thread-name-prefix: report-

# 报表缓存配置
report:
  cache:
    default-duration: 300
    max-size: 1000
```

### 8.2 JVM配置

```bash
java -jar qooerp-report-start.jar \
  -Xms512m \
  -Xmx1024m \
  -XX:+UseG1GC \
  -XX:MaxGCPauseMillis=200 \
  -XX:+HeapDumpOnOutOfMemoryError \
  -XX:HeapDumpPath=/var/log/qooerp-report/
```

---

## 九、扩展设计

### 9.1 插件机制

```java
public interface ReportDataPlugin {
    String getName();
    Map<String, Object> execute(String config, Map<String, Object> params);
    boolean validate(String config);
}

@Component
public class PluginManager {
    
    private final Map<String, ReportDataPlugin> plugins = new ConcurrentHashMap<>();
    
    @Autowired
    public void registerPlugins(List<ReportDataPlugin> pluginList) {
        pluginList.forEach(plugin -> 
            plugins.put(plugin.getName(), plugin)
        );
    }
    
    public ReportDataPlugin getPlugin(String name) {
        return plugins.get(name);
    }
}
```

### 9.2 自定义图表

```java
public interface ChartRenderer {
    String renderChart(ReportConfig config, Map<String, Object> data);
}
```

---

**文档版本**: v1.1  
**最后更新**: 20xx-xx-xx
