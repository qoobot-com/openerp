# QooERP 工作流引擎模块 - 技术设计文档

> 模块名称: qooerp-workflow
> 模块版本: v2.0
> 创建日期: 20xx-xx-xx
> 更新日期: 20xx-xx-xx
> 作者: Auto

---

## 一、技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Spring Boot | 3.3.6 | 核心框架 |
| Spring Cloud | 2023.0.3 | 微服务框架 |
| Flowable | 7.0.0 | 工作流引擎 |
| MyBatis-Plus | 3.5.7 | ORM框架 |
| PostgreSQL | 15+ | 数据库 |
| Redis | 7.x | 缓存 |
| Nacos | 2.x | 配置中心/注册中心 |
| SpringDoc OpenAPI | 2.3.0 | API文档 |
| Hutool | 5.8.23 | 工具库 |

---

## 二、核心功能实现

### 2.1 Flowable 引擎配置

```java
@Configuration
@EnableFlowable
public class FlowableConfig {

    @Bean
    public ProcessEngine processEngine(DataSource dataSource) {
        ProcessEngineConfiguration config = StandaloneProcessEngineConfiguration
            .createStandaloneProcessEngineConfiguration();

        config.setDataSource(dataSource);
        config.setDatabaseSchemaUpdate(ProcessEngineConfiguration.DB_SCHEMA_UPDATE_TRUE);
        config.setAsyncExecutorActivate(true);
        config.setAsyncHistoryEnabled(true);
        config.setHistoryLevel(HistoryLevel.AUDIT);
        config.setAsyncExecutorActivate(true);

        // ID生成策略
        config.setIdGenerator(uuidIdGenerator());

        // 事件监听器
        config.setEventListeners(Arrays.asList(
            new WorkflowEventListener(),
            new NotificationEventListener()
        ));

        return config.buildProcessEngine();
    }

    @Bean
    public IdGenerator uuidIdGenerator() {
        return new StrongUuidGenerator();
    }
}
```

### 2.2 流程启动服务实现

```java
@Service
@Slf4j
public class WorkflowInstanceServiceImpl implements WorkflowInstanceService {

    @Autowired
    private RuntimeService runtimeService;

    @Autowired
    private TaskService taskService;

    @Autowired
    private HistoryService historyService;

    @Autowired
    private WorkflowInstanceMapper instanceMapper;

    @Autowired
    private WorkflowVariableMapper variableMapper;

    @Autowired
    private WorkflowLogMapper logMapper;

    @Autowired
    private WorkflowNotificationService notificationService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public WorkflowInstanceDTO startInstance(InstanceStartDTO dto) {
        // 1. 验证流程定义
        ProcessDefinition definition = repositoryService
            .createProcessDefinitionQuery()
            .processDefinitionId(dto.getDefinitionId())
            .active()
            .singleResult();

        if (definition == null) {
            throw new WorkflowDefinitionNotFoundException("流程定义不存在或未发布");
        }

        // 2. 构建流程变量
        Map<String, Object> variables = dto.getVariables();
        if (variables == null) {
            variables = new HashMap<>();
        }
        variables.put("startUserId", SecurityContextHolder.getUserId());
        variables.put("startUserName", SecurityContextHolder.getUserName());
        variables.put("startTime", new Date());

        // 3. 启动流程实例
        ProcessInstance instance = runtimeService.startProcessInstanceById(
            dto.getDefinitionId(),
            dto.getBusinessKey(),
            variables
        );

        // 4. 保存流程实例到业务表
        WorkflowInstance workflowInstance = new WorkflowInstance();
        workflowInstance.setInstanceId(instance.getId());
        workflowInstance.setDefinitionId(instance.getProcessDefinitionId());
        workflowInstance.setDefinitionKey(definition.getKey());
        workflowInstance.setInstanceName(dto.getInstanceName());
        workflowInstance.setBusinessKey(dto.getBusinessKey());
        workflowInstance.setStatus(WorkflowInstanceStatus.RUNNING.getCode());
        workflowInstance.setStartTime(new Date());
        workflowInstance.setStartUserId(SecurityContextHolder.getUserId());
        workflowInstance.setStartUserName(SecurityContextHolder.getUserName());
        workflowInstance.setCurrentNode(instance.getActivityId());
        instanceMapper.insert(workflowInstance);

        // 5. 保存流程变量
        saveVariables(instance.getId(), variables);

        // 6. 保存表单数据
        if (dto.getFormData() != null && !dto.getFormData().isEmpty()) {
            saveFormData(instance.getId(), dto.getFormData());
        }

        // 7. 记录启动日志
        saveWorkflowLog(instance.getId(), null, "START",
            "启动流程: " + dto.getInstanceName());

        // 8. 发送通知
        notificationService.sendStartNotification(instance.getId());

        return convertToDTO(workflowInstance);
    }

    private void saveVariables(String instanceId, Map<String, Object> variables) {
        if (variables == null || variables.isEmpty()) {
            return;
        }

        List<WorkflowVariable> list = variables.entrySet().stream()
            .map(entry -> {
                WorkflowVariable variable = new WorkflowVariable();
                variable.setInstanceId(instanceId);
                variable.setVariableName(entry.getKey());
                variable.setVariableValue(JSON.toJSONString(entry.getValue()));
                variable.setVariableType(getVariableType(entry.getValue()));
                variable.setVariableScope("global");
                return variable;
            })
            .collect(Collectors.toList());

        variableMapper.saveBatch(list);
    }

    private String getVariableType(Object value) {
        if (value == null) {
            return "null";
        } else if (value instanceof String) {
            return "string";
        } else if (value instanceof Integer) {
            return "integer";
        } else if (value instanceof Long) {
            return "long";
        } else if (value instanceof Boolean) {
            return "boolean";
        } else if (value instanceof Date) {
            return "date";
        } else {
            return "json";
        }
    }
}
```

### 2.3 任务完成服务实现

```java
@Service
@Slf4j
public class WorkflowTaskServiceImpl implements WorkflowTaskService {

    @Autowired
    private TaskService taskService;

    @Autowired
    private RuntimeService runtimeService;

    @Autowired
    private HistoryService historyService;

    @Autowired
    private WorkflowTaskMapper taskMapper;

    @Autowired
    private WorkflowLogMapper logMapper;

    @Autowired
    private WorkflowFormService formService;

    @Autowired
    private WorkflowNotificationService notificationService;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void completeTask(TaskCompleteDTO dto) {
        // 1. 查询任务
        Task task = taskService.createTaskQuery()
            .taskId(dto.getTaskId())
            .singleResult();

        if (task == null) {
            throw new TaskNotFoundException("任务不存在或已被处理");
        }

        // 2. 验证权限
        if (!task.getAssignee().equals(SecurityContextHolder.getUserId().toString())) {
            throw new TaskPermissionException("无权限处理该任务");
        }

        // 3. 检查是否需要会签
        boolean needSign = checkNeedSign(task);
        if (needSign) {
            handleSignTask(task, dto);
            return;
        }

        // 4. 保存表单数据
        if (dto.getFormData() != null && !dto.getFormData().isEmpty()) {
            formService.saveFormData(task.getProcessInstanceId(),
                dto.getTaskId(), dto.getFormData());
        }

        // 5. 构建流程变量
        Map<String, Object> variables = dto.getVariables();
        if (variables == null) {
            variables = new HashMap<>();
        }
        variables.put("approved", true);
        variables.put("comment", dto.getComment());
        variables.put("approverId", SecurityContextHolder.getUserId());
        variables.put("approverName", SecurityContextHolder.getUserName());
        variables.put("approveTime", new Date());

        // 6. 完成任务
        taskService.complete(dto.getTaskId(), variables);

        // 7. 更新任务状态
        updateTaskStatus(dto.getTaskId(), WorkflowTaskStatus.COMPLETED);

        // 8. 记录操作日志
        saveWorkflowLog(task.getProcessInstanceId(), task.getId(),
            "COMPLETE", dto.getComment());

        // 9. 检查流程是否结束
        checkProcessEnd(task.getProcessInstanceId());

        // 10. 发送通知
        sendApprovalNotification(task, true);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void rejectTask(TaskRejectDTO dto) {
        // 1. 查询任务
        Task task = taskService.createTaskQuery()
            .taskId(dto.getTaskId())
            .singleResult();

        if (task == null) {
            throw new TaskNotFoundException("任务不存在或已被处理");
        }

        // 2. 验证权限
        if (!task.getAssignee().equals(SecurityContextHolder.getUserId().toString())) {
            throw new TaskPermissionException("无权限处理该任务");
        }

        // 3. 设置驳回变量
        Map<String, Object> variables = new HashMap<>();
        variables.put("approved", false);
        variables.put("comment", dto.getComment());
        variables.put("rejectTo", dto.getRejectTo());
        variables.put("approverId", SecurityContextHolder.getUserId());
        variables.put("approverName", SecurityContextHolder.getUserName());

        // 4. 驳回任务
        if (StringUtils.isNotBlank(dto.getRejectTo())) {
            runtimeService.createExecutionQuery()
                .executionId(task.getExecutionId())
                .singleResult();
            // 回退到指定节点
            runtimeService.createChangeActivityStateBuilder()
                .processInstanceId(task.getProcessInstanceId())
                .moveActivityIdTo(dto.getRejectTo());
        } else {
            // 默认驳回到上一节点
            runtimeService.createChangeActivityStateBuilder()
                .processInstanceId(task.getProcessInstanceId())
                .moveActivityIdToActivityId(task.getTaskDefinitionKey(), getPreviousTask(task));
        }

        taskService.complete(dto.getTaskId(), variables);

        // 5. 更新任务状态
        updateTaskStatus(dto.getTaskId(), WorkflowTaskStatus.REJECTED);

        // 6. 记录操作日志
        saveWorkflowLog(task.getProcessInstanceId(), task.getId(),
            "REJECT", dto.getComment());

        // 7. 发送通知
        sendApprovalNotification(task, false);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void transferTask(String taskId, Long targetUserId) {
        // 1. 查询任务
        Task task = taskService.createTaskQuery()
            .taskId(taskId)
            .singleResult();

        if (task == null) {
            throw new TaskNotFoundException("任务不存在");
        }

        // 2. 验证权限
        if (!task.getAssignee().equals(SecurityContextHolder.getUserId().toString())) {
            throw new TaskPermissionException("无权限转派该任务");
        }

        // 3. 转派任务
        taskService.setOwner(taskId, task.getAssignee());
        taskService.setAssignee(taskId, targetUserId.toString());

        // 4. 记录日志
        saveWorkflowLog(task.getProcessInstanceId(), task.getId(),
            "TRANSFER", "转派给用户: " + targetUserId);

        // 5. 发送通知
        notificationService.sendTodoNotification(taskId, targetUserId);
    }

    private boolean checkNeedSign(Task task) {
        // 检查是否需要会签
        return false;
    }

    private void handleSignTask(Task task, TaskCompleteDTO dto) {
        // 处理会签任务
    }
}
```

### 2.4 表单服务实现

```java
@Service
@Slf4j
public class WorkflowFormServiceImpl implements WorkflowFormService {

    @Autowired
    private WorkflowFormMapper formMapper;

    @Autowired
    private WorkflowFormFieldMapper fieldMapper;

    @Autowired
    private WorkflowFormRecordMapper recordMapper;

    @Autowired
    private WorkflowFormValidator formValidator;

    @Override
    @Transactional(rollbackFor = Exception.class)
    public WorkflowFormDTO createForm(WorkflowFormDTO dto) {
        WorkflowForm form = convertToEntity(dto);
        form.setFormKey(generateFormKey(dto.getFormName()));
        form.setCreateTime(new Date());
        form.setStatus(0);
        formMapper.insert(form);

        // 保存表单字段
        if (dto.getFields() != null && !dto.getFields().isEmpty()) {
            List<WorkflowFormField> fields = dto.getFields().stream()
                .map(fieldDTO -> {
                    WorkflowFormField field = new WorkflowFormField();
                    BeanUtils.copyProperties(fieldDTO, field);
                    field.setFormId(form.getId());
                    field.setCreateTime(new Date());
                    return field;
                })
                .collect(Collectors.toList());
            fieldMapper.saveBatch(fields);
        }

        return convertToDTO(form);
    }

    @Override
    @Transactional(rollbackFor = Exception.class)
    public void saveFormData(String instanceId, String taskId,
                             Map<String, Object> formData) {
        // 验证表单数据
        formValidator.validate(formData);

        // 保存表单数据记录
        WorkflowFormRecord record = new WorkflowFormRecord();
        record.setRecordId(UUID.randomUUID().toString());
        record.setInstanceId(instanceId);
        record.setTaskId(taskId);
        record.setFormData(JSON.toJSONString(formData));
        record.setSubmitTime(new Date());
        record.setSubmitUserId(SecurityContextHolder.getUserId());
        record.setSubmitUserName(SecurityContextHolder.getUserName());
        recordMapper.insert(record);
    }

    @Override
    public FormRecordDTO getFormData(String recordId) {
        WorkflowFormRecord record = recordMapper.selectById(recordId);
        if (record == null) {
            throw new FormRecordNotFoundException("表单数据不存在");
        }

        FormRecordDTO dto = new FormRecordDTO();
        dto.setRecordId(record.getRecordId());
        dto.setInstanceId(record.getInstanceId());
        dto.setTaskId(record.getTaskId());
        dto.setFormData(JSON.parseObject(record.getFormData()));
        dto.setSubmitTime(record.getSubmitTime());
        dto.setSubmitUserId(record.getSubmitUserId());
        dto.setSubmitUserName(record.getSubmitUserName());

        return dto;
    }

    private String generateFormKey(String formName) {
        return "form_" + PinyinUtil.getFirstLetter(formName, "")
            + "_" + System.currentTimeMillis();
    }
}
```

### 2.5 消息通知服务实现

```java
@Service
@Slf4j
public class WorkflowNotificationServiceImpl implements WorkflowNotificationService {

    @Autowired
    private WorkflowNotificationMapper notificationMapper;

    @Autowired
    private List<NotificationProvider> notificationProviders;

    @Autowired
    private NotifyClient notifyClient;

    @Autowired
    private MessageClient messageClient;

    @Override
    public void sendTodoNotification(String taskId, Long userId) {
        Task task = taskService.createTaskQuery()
            .taskId(taskId)
            .singleResult();

        if (task == null) {
            return;
        }

        // 获取通知配置
        List<String> notificationTypes = getNotificationTypes();

        // 构建通知消息
        NotificationMessage message = NotificationMessage.builder()
            .type("todo")
            .targetId(taskId)
            .targetType("task")
            .receiverId(userId)
            .title("新待办任务")
            .content(String.format("您有新的待办任务：%s", task.getName()))
            .build();

        // 发送通知
        sendNotification(message, notificationTypes);
    }

    @Override
    public void sendApprovalNotification(String instanceId, Long userId,
                                          boolean approved) {
        // 构建通知消息
        NotificationMessage message = NotificationMessage.builder()
            .type(approved ? "approval_approve" : "approval_reject")
            .targetId(instanceId)
            .targetType("instance")
            .receiverId(userId)
            .title(approved ? "审批通过通知" : "审批驳回通知")
            .content(approved ? "您的申请已审批通过" : "您的申请已被驳回")
            .build();

        // 发送通知
        sendNotification(message, getNotificationTypes());
    }

    @Override
    public void sendOverdueReminder(String taskId) {
        Task task = taskService.createTaskQuery()
            .taskId(taskId)
            .singleResult();

        if (task == null) {
            return;
        }

        NotificationMessage message = NotificationMessage.builder()
            .type("overdue")
            .targetId(taskId)
            .targetType("task")
            .receiverId(Long.parseLong(task.getAssignee()))
            .title("任务超时提醒")
            .content(String.format("您的任务《%s》已超时，请及时处理", task.getName()))
            .build();

        sendNotification(message, Arrays.asList("site-message", "wechat"));
    }

    private void sendNotification(NotificationMessage message,
                                  List<String> types) {
        // 保存通知记录
        saveNotificationRecord(message, types);

        // 发送通知
        types.forEach(type -> {
            NotificationProvider provider = getNotificationProvider(type);
            if (provider != null) {
                try {
                    provider.sendNotification(message);
                    log.info("发送{}通知成功，消息ID: {}", type, message.getTargetId());
                } catch (Exception e) {
                    log.error("发送{}通知失败，消息ID: {}", type, message.getTargetId(), e);
                }
            }
        });
    }

    private NotificationProvider getNotificationProvider(String type) {
        return notificationProviders.stream()
            .filter(provider -> provider.supports(type))
            .findFirst()
            .orElse(null);
    }

    private List<String> getNotificationTypes() {
        // 从配置中心获取通知类型配置
        return Arrays.asList("site-message", "wechat");
    }

    private void saveNotificationRecord(NotificationMessage message,
                                         List<String> types) {
        types.forEach(type -> {
            WorkflowNotification notification = new WorkflowNotification();
            notification.setNotificationType(message.getType());
            notification.setTargetId(message.getTargetId());
            notification.setTargetType(message.getTargetType());
            notification.setReceiverId(message.getReceiverId());
            notification.setNotificationMethod(type);
            notification.setTitle(message.getTitle());
            notification.setContent(message.getContent());
            notification.setSendStatus(0);
            notification.setCreateTime(new Date());
            notificationMapper.insert(notification);
        });
    }
}
```

---

## 三、扩展点设计

### 3.1 流程监听器

```java
@Component
@Slf4j
public class WorkflowEventListener implements FlowableEventListener {

    @Override
    public void onEvent(FlowableEvent event) {
        if (event instanceof FlowableEntityEvent) {
            FlowableEntityEvent entityEvent = (FlowableEntityEvent) event;
            if (entityEvent.getEntity() instanceof TaskEntity) {
                handleTaskEvent(event);
            } else if (entityEvent.getEntity() instanceof ExecutionEntity) {
                handleExecutionEvent(event);
            }
        }
    }

    private void handleTaskEvent(FlowableEvent event) {
        switch (event.getType()) {
            case TaskEvents.TASK_CREATED:
                onTaskCreated((TaskEntity) ((FlowableEntityEvent) event).getEntity());
                break;
            case TaskEvents.TASK_COMPLETED:
                onTaskCompleted((TaskEntity) ((FlowableEntityEvent) event).getEntity());
                break;
        }
    }

    private void handleExecutionEvent(FlowableEvent event) {
        switch (event.getType()) {
            case ExecutionEventName.PROCESS_STARTED:
                onProcessStarted((ExecutionEntity) ((FlowableEntityEvent) event).getEntity());
                break;
            case ExecutionEventName.PROCESS_COMPLETED:
                onProcessCompleted((ExecutionEntity) ((FlowableEntityEvent) event).getEntity());
                break;
        }
    }

    private void onTaskCreated(TaskEntity task) {
        log.info("任务创建: {}", task.getName());
    }

    private void onTaskCompleted(TaskEntity task) {
        log.info("任务完成: {}", task.getName());
    }

    private void onProcessStarted(ExecutionEntity execution) {
        log.info("流程启动: {}", execution.getProcessDefinitionId());
    }

    private void onProcessCompleted(ExecutionEntity execution) {
        log.info("流程完成: {}", execution.getProcessDefinitionId());
    }

    @Override
    public boolean isFailOnException() {
        return false;
    }

    @Override
    public boolean isFireOnTransactionLifecycleEvent() {
        return false;
    }

    @Override
    public String getOnTransaction() {
        return null;
    }
}
```

### 3.2 通知提供者接口

```java
public interface NotificationProvider {

    /**
     * 发送通知
     */
    void sendNotification(NotificationMessage message);

    /**
     * 支持的通知类型
     */
    boolean supports(String type);
}

@Component
@Slf4j
public class SiteMessageNotificationProvider implements NotificationProvider {

    @Autowired
    private MessageClient messageClient;

    @Override
    public void sendNotification(NotificationMessage message) {
        SendMessageDTO dto = new SendMessageDTO();
        dto.setReceiverId(message.getReceiverId());
        dto.setTitle(message.getTitle());
        dto.setContent(message.getContent());
        dto.setType(message.getType());
        messageClient.sendMessage(dto);
    }

    @Override
    public boolean supports(String type) {
        return "site-message".equals(type);
    }
}

@Component
@Slf4j
public class WechatNotificationProvider implements NotificationProvider {

    @Autowired
    private NotifyClient notifyClient;

    @Override
    public void sendNotification(NotificationMessage message) {
        WechatMessageDTO dto = new WechatMessageDTO();
        dto.setReceiverId(message.getReceiverId());
        dto.setTitle(message.getTitle());
        dto.setContent(message.getContent());
        notifyClient.sendWechatMessage(dto);
    }

    @Override
    public boolean supports(String type) {
        return "wechat".equals(type);
    }
}
```

---

## 四、性能优化

### 4.1 缓存策略

```java
@Configuration
@EnableCaching
public class CacheConfig {

    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}

@Service
public class WorkflowDefinitionServiceImpl implements WorkflowDefinitionService {

    @Cacheable(value = "workflow:definition", key = "#id",
               unless = "#result == null")
    public WorkflowDefinitionDTO getDefinition(Long id) {
        // ...
    }

    @CacheEvict(value = "workflow:definition", key = "#id")
    public void updateDefinition(Long id, WorkflowDefinitionDTO dto) {
        // ...
    }
}
```

### 4.2 异步处理

```java
@Service
@Slf4j
public class WorkflowNotificationServiceImpl {

    @Async("taskExecutor")
    public void sendNotificationAsync(NotificationMessage message,
                                        List<String> types) {
        sendNotification(message, types);
    }
}

@Configuration
public class AsyncConfig {

    @Bean("taskExecutor")
    public ThreadPoolTaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("workflow-async-");
        executor.setRejectedExecutionHandler(
            new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

---

## 五、部署配置

### 5.1 application-prod.yml

```yaml
server:
  port: 8095

spring:
  application:
    name: qooerp-workflow
  profiles:
    active: prod
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://${DB_HOST:localhost}:${DB_PORT:5432}/${DB_NAME:qooerp_workflow}
    username: ${DB_USERNAME:qooerp_workflow}
    password: ${DB_PASSWORD:qooerp_workflow_2026}
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: ${REDIS_DB:0}
      lettuce:
        pool:
          max-active: 8
          max-wait: -1
          max-idle: 8
          min-idle: 0

# Flowable 配置
flowable:
  database-schema-update: false
  async-executor-activate: true
  history-level: audit
  database-type: postgres
  process-definition-cache-limit: 100

# Nacos 配置
spring:
  cloud:
    nacos:
      discovery:
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
        namespace: ${NACOS_NAMESPACE:qooerp}
        group: WORKFLOW_GROUP
      config:
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
        namespace: ${NACOS_NAMESPACE:qooerp}
        group: WORKFLOW_GROUP
        file-extension: yaml

# 日志配置
logging:
  level:
    com.qoobot.qooerp.workflow: ${LOG_LEVEL:INFO}
    org.flowable: ${FLOWABLE_LOG_LEVEL:INFO}
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
    file: "%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{50} - %msg%n"
  file:
    name: /var/log/qooerp/workflow.log
    max-size: 100MB
    max-history: 30
```

---

## 六、监控指标

| 指标名称 | 说明 | 类型 |
|---------|------|------|
| workflow_instance_total | 流程实例总数 | Counter |
| workflow_task_total | 任务总数 | Counter |
| workflow_task_pending | 待处理任务数 | Gauge |
| workflow_task_completed | 已完成任务数 | Counter |
| workflow_task_overdue | 超时任务数 | Gauge |
| workflow_complete_duration | 流程完成时长 | Histogram |
| workflow_task_duration | 任务处理时长 | Histogram |

---

## 七、常见问题

### 7.1 流程定义冲突

**问题**：部署流程定义时提示版本冲突

**解决**：
```java
// 检查流程定义是否存在
ProcessDefinition existing = repositoryService
    .createProcessDefinitionQuery()
    .processDefinitionKey(definitionKey)
    .latestVersion()
    .singleResult();

if (existing != null) {
    // 挂起旧版本
    repositoryService.suspendProcessDefinitionById(
        existing.getId());
}
```

### 7.2 任务分配问题

**问题**：任务未正确分配给审批人

**解决**：
```java
// 确保任务监听器正确设置
TaskListener taskListener = (delegateTask) -> {
    String assignee = calculateAssignee(delegateTask);
    delegateTask.setAssignee(assignee);
};
```

---

**文档版本**: v2.0
**最后更新**: 20xx-xx-xx
**数据库**: PostgreSQL 15+
