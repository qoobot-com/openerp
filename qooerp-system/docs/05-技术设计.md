# QooERP System 模块 - 技术设计文档

## 1. 技术选型

### 1.1 核心技术栈

| 技术组件 | 版本 | 用途 |
|---------|------|------|
| Spring Boot | 3.x | 应用框架 |
| Spring Task | 3.x | 定时任务 |
| MyBatis-Plus | 3.5.x | ORM框架 |
| PostgreSQL | 15+ | 关系型数据库 |
| Redis | 7.x | 缓存数据库 |
| Nacos | 2.x | 配置中心和服务发现 |
| MinIO/OSS | - | 对象存储 |
| EasyExcel | 3.x | Excel导入导出 |

### 1.2 依赖模块

```xml
<dependencies>
    <!-- 公共模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-api</artifactId>
    </dependency>
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-core</artifactId>
    </dependency>
    
    <!-- 认证模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-auth-api</artifactId>
    </dependency>
    
    <!-- 权限模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-permission-api</artifactId>
    </dependency>
    
    <!-- 数据库 -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
    
    <!-- 缓存 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- Excel处理 -->
    <dependency>
        <groupId>com.alibaba</groupId>
        <artifactId>easyexcel</artifactId>
        <version>3.3.2</version>
    </dependency>
    
    <!-- 文件上传 -->
    <dependency>
        <groupId>commons-fileupload</groupId>
        <artifactId>commons-fileupload</artifactId>
        <version>1.5</version>
    </dependency>
    
    <!-- 定时任务 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-quartz</artifactId>
    </dependency>
    
    <!-- 注册中心和配置中心 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
</dependencies>
```

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   客户端层 (Web/Mobile)                   │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                    API Gateway                            │
│              (路由、认证、限流)                            │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│               System Service                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │              Controller 层                         │  │
│  │  - SystemDictController                            │  │
│  │  - SystemConfigController                          │  │
│  │  - SystemParamController                           │  │
│  │  - SystemFileController                           │  │
│  │  - SystemLogController                             │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              Service 层                             │  │
│  │  - SystemDictService                               │  │
│  │  - SystemConfigService                             │  │
│  │  - SystemParamService                              │  │
│  │  - SystemFileService                               │  │
│  │  - SystemLogService                                │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              Mapper 层                              │  │
│  │  - SystemDictMapper                                │  │
│  │  - SystemDictItemMapper                            │  │
│  │  - SystemConfigMapper                              │  │
│  │  - SystemParamMapper                               │  │
│  │  - SystemFileMapper                                │  │
│  │  - SystemLogMapper                                 │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              数据访问层                             │  │
│  │  - MyBatis-Plus                                     │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────┬──────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┬────────────┐
        │              │              │            │
┌───────▼──────┐ ┌────▼─────┐ ┌──────▼─────┐ ┌───▼────┐
│  PostgreSQL  │ │  Redis   │ │  Local/OSS │ │ Nacos  │
│   (持久化)   │ │  (缓存)  │ │  (存储)    │ │(配置)  │
└──────────────┘ └──────────┘ └────────────┘ └────────┘
```

### 2.2 文件存储架构

```
文件上传请求 → Controller → Service → 存储策略选择器
                                                 ↓
                                 ┌──────────────┼──────────────┐
                                 ↓              ↓              ↓
                             LocalStorage   OSSStorage    MinIOStorage
                                 │              │              │
                                 ↓              ↓              ↓
                            本地文件系统    阿里云OSS      MinIO服务器
```

## 3. 核心功能实现

### 3.1 字典缓存实现

#### 字典缓存服务

```java
@Service
public class SystemDictCacheService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String DICT_CACHE_KEY = "system:dict:";
    private static final String DICT_ITEM_CACHE_KEY = "system:dict:item:";
    private static final long CACHE_EXPIRE_SECONDS = 3600; // 1小时
    
    /**
     * 获取字典类型缓存
     */
    public SystemDictVO getDictByCode(String dictCode) {
        String key = DICT_CACHE_KEY + dictCode;
        SystemDictVO dict = (SystemDictVO) redisTemplate.opsForValue().get(key);
        
        if (dict == null) {
            dict = systemDictMapper.selectByCode(dictCode);
            if (dict != null) {
                redisTemplate.opsForValue().set(key, dict, CACHE_EXPIRE_SECONDS, TimeUnit.SECONDS);
            }
        }
        
        return dict;
    }
    
    /**
     * 获取字典项列表缓存
     */
    public List<SystemDictItemVO> getDictItemsByCode(String dictCode) {
        String key = DICT_ITEM_CACHE_KEY + dictCode;
        List<SystemDictItemVO> items = (List<SystemDictItemVO>) redisTemplate.opsForValue().get(key);
        
        if (items == null) {
            items = systemDictItemMapper.selectByDictCode(dictCode);
            if (items != null) {
                redisTemplate.opsForValue().set(key, items, CACHE_EXPIRE_SECONDS, TimeUnit.SECONDS);
            }
        }
        
        return items;
    }
    
    /**
     * 清除字典缓存
     */
    public void clearDictCache(String dictCode) {
        redisTemplate.delete(DICT_CACHE_KEY + dictCode);
        redisTemplate.delete(DICT_ITEM_CACHE_KEY + dictCode);
    }
}
```

### 3.2 文件存储策略

#### 存储策略接口

```java
public interface FileStorageStrategy {
    
    /**
     * 上传文件
     */
    String upload(MultipartFile file, String module, String datePath) throws IOException;
    
    /**
     * 删除文件
     */
    void delete(String filePath) throws IOException;
    
    /**
     * 获取文件访问URL
     */
    String getFileUrl(String filePath);
    
    /**
     * 检查文件是否存在
     */
    boolean exists(String filePath);
}
```

#### 本地存储实现

```java
@Component("localStorage")
public class LocalStorageStrategy implements FileStorageStrategy {
    
    @Value("${file.upload.path:/data/qooerp/files}")
    private String uploadPath;
    
    @Value("${file.access.url:/file}")
    private String accessUrl;
    
    @Override
    public String upload(MultipartFile file, String module, String datePath) throws IOException {
        String fileName = generateFileName(file.getOriginalFilename());
        String relativePath = module + "/" + datePath + "/" + fileName;
        String fullPath = uploadPath + "/" + relativePath;
        
        File destFile = new File(fullPath);
        destFile.getParentFile().mkdirs();
        file.transferTo(destFile);
        
        return relativePath;
    }
    
    @Override
    public void delete(String filePath) throws IOException {
        String fullPath = uploadPath + "/" + filePath;
        File file = new File(fullPath);
        if (file.exists()) {
            file.delete();
        }
    }
    
    @Override
    public String getFileUrl(String filePath) {
        return accessUrl + "/" + filePath;
    }
    
    @Override
    public boolean exists(String filePath) {
        String fullPath = uploadPath + "/" + filePath;
        return new File(fullPath).exists();
    }
    
    private String generateFileName(String originalName) {
        String ext = FilenameUtils.getExtension(originalName);
        return UUID.randomUUID().toString() + "." + ext;
    }
}
```

#### OSS存储实现

```java
@Component("ossStorage")
public class OssStorageStrategy implements FileStorageStrategy {
    
    @Value("${aliyun.oss.endpoint}")
    private String endpoint;
    
    @Value("${aliyun.oss.accessKeyId}")
    private String accessKeyId;
    
    @Value("${aliyun.oss.accessKeySecret}")
    private String accessKeySecret;
    
    @Value("${aliyun.oss.bucketName}")
    private String bucketName;
    
    @Override
    public String upload(MultipartFile file, String module, String datePath) throws IOException {
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        
        String fileName = generateFileName(file.getOriginalFilename());
        String objectName = module + "/" + datePath + "/" + fileName;
        
        ossClient.putObject(bucketName, objectName, file.getInputStream());
        
        ossClient.shutdown();
        
        return objectName;
    }
    
    @Override
    public void delete(String filePath) {
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        ossClient.deleteObject(bucketName, filePath);
        ossClient.shutdown();
    }
    
    @Override
    public String getFileUrl(String filePath) {
        return "https://" + bucketName + "." + endpoint + "/" + filePath;
    }
    
    @Override
    public boolean exists(String filePath) {
        OSS ossClient = new OSSClientBuilder().build(endpoint, accessKeyId, accessKeySecret);
        boolean exists = ossClient.doesObjectExist(bucketName, filePath);
        ossClient.shutdown();
        return exists;
    }
    
    private String generateFileName(String originalName) {
        String ext = FilenameUtils.getExtension(originalName);
        return UUID.randomUUID().toString() + "." + ext;
    }
}
```

#### 存储策略工厂

```java
@Service
public class FileStorageFactory {
    
    @Autowired
    private Map<String, FileStorageStrategy> storageStrategyMap;
    
    public FileStorageStrategy getStorageStrategy(String storageType) {
        String beanName = storageType + "Storage";
        FileStorageStrategy strategy = storageStrategyMap.get(beanName);
        if (strategy == null) {
            throw new BusinessException("不支持的存储类型: " + storageType);
        }
        return strategy;
    }
}
```

### 3.3 日志异步处理

#### 异步日志服务

```java
@Service
public class SystemLogServiceImpl implements SystemLogService {
    
    @Autowired
    private SystemLogMapper systemLogMapper;
    
    @Autowired
    private SystemLogQueue logQueue;
    
    /**
     * 同步保存日志
     */
    @Override
    public void saveLog(SystemLogDTO logDTO) {
        SystemLog log = BeanUtil.copyProperties(logDTO, SystemLog.class);
        log.setUserId(SecurityUtils.getUserId());
        log.setUsername(SecurityUtils.getUsername());
        
        HttpServletRequest request = ServletUtils.getRequest();
        log.setIp(IpUtils.getIpAddr(request));
        log.setLocation(IpUtils.getLocation(log.getIp()));
        log.setUserAgent(request.getHeader("User-Agent"));
        
        systemLogMapper.insert(log);
    }
    
    /**
     * 异步保存日志
     */
    @Async
    @Override
    public void saveLogAsync(SystemLogDTO logDTO) {
        saveLog(logDTO);
    }
    
    /**
     * 批量异步保存日志
     */
    @Override
    public void batchSaveLog(List<SystemLogDTO> logList) {
        List<SystemLog> logs = logList.stream()
            .map(dto -> {
                SystemLog log = BeanUtil.copyProperties(dto, SystemLog.class);
                log.setUserId(SecurityUtils.getUserId());
                log.setUsername(SecurityUtils.getUsername());
                return log;
            })
            .collect(Collectors.toList());
        
        systemLogMapper.batchInsert(logs);
    }
}
```

#### 日志队列

```java
@Component
public class SystemLogQueue {
    
    private final Queue<SystemLogDTO> queue = new ConcurrentLinkedQueue<>();
    
    private final int BATCH_SIZE = 100;
    
    @Autowired
    private SystemLogService systemLogService;
    
    /**
     * 添加日志到队列
     */
    public void addLog(SystemLogDTO logDTO) {
        queue.offer(logDTO);
    }
    
    /**
     * 批量处理队列中的日志
     */
    @Scheduled(fixedDelay = 5000)
    public void processLogs() {
        List<SystemLogDTO> batch = new ArrayList<>();
        
        while (!queue.isEmpty() && batch.size() < BATCH_SIZE) {
            SystemLogDTO log = queue.poll();
            if (log != null) {
                batch.add(log);
            }
        }
        
        if (!batch.isEmpty()) {
            systemLogService.batchSaveLog(batch);
        }
    }
}
```

### 3.4 定时任务实现

#### Quartz定时任务配置

```java
@Configuration
public class QuartzConfig {
    
    @Autowired
    private SystemJobMapper systemJobMapper;
    
    /**
     * 定时任务工厂
     */
    @Bean
    public SchedulerFactoryBean schedulerFactoryBean() {
        SchedulerFactoryBean factory = new SchedulerFactoryBean();
        factory.setJobFactory(springBeanJobFactory());
        return factory;
    }
    
    @Bean
    public SpringBeanJobFactory springBeanJobFactory() {
        AutowiringSpringBeanJobFactory jobFactory = new AutowiringSpringBeanJobFactory();
        jobFactory.setApplicationContext(applicationContext);
        return jobFactory;
    }
    
    /**
     * 初始化定时任务
     */
    @PostConstruct
    public void initJobs() {
        List<SystemJob> jobs = systemJobMapper.selectList(
            new LambdaQueryWrapper<SystemJob>().eq(SystemJob::getStatus, 1)
        );
        
        for (SystemJob job : jobs) {
            scheduleJob(job);
        }
    }
    
    /**
     * 调度任务
     */
    public void scheduleJob(SystemJob job) {
        try {
            Scheduler scheduler = schedulerFactoryBean().getScheduler();
            
            JobDetail jobDetail = JobBuilder.newJob(InvokeMethodJob.class)
                .withIdentity(job.getJobName(), job.getJobGroup())
                .build();
            
            CronTrigger trigger = TriggerBuilder.newTrigger()
                .withIdentity(job.getJobName(), job.getJobGroup())
                .withSchedule(CronScheduleBuilder.cronSchedule(job.getCronExpression()))
                .build();
            
            scheduler.scheduleJob(jobDetail, trigger);
            
            if (!scheduler.isStarted()) {
                scheduler.start();
            }
        } catch (SchedulerException e) {
            throw new BusinessException("定时任务调度失败: " + e.getMessage());
        }
    }
}
```

#### 动态任务执行

```java
public class InvokeMethodJob extends QuartzJobBean {
    
    @Override
    protected void executeInternal(JobExecutionContext context) throws JobExecutionException {
        String beanName = context.getMergedJobDataMap().getString("beanName");
        String methodName = context.getMergedJobDataMap().getString("methodName");
        String methodParams = context.getMergedJobDataMap().getString("methodParams");
        
        try {
            Object bean = SpringUtils.getBean(beanName);
            Method method = bean.getClass().getDeclaredMethod(methodName);
            method.invoke(bean);
        } catch (Exception e) {
            throw new JobExecutionException(e);
        }
    }
}
```

## 4. 缓存设计

### 4.1 缓存策略

| 数据类型 | 缓存Key | 过期时间 | 更新策略 |
|---------|---------|----------|----------|
| 字典类型 | system:dict:{code} | 1小时 | 字典变更时清除 |
| 字典项 | system:dict:item:{code} | 1小时 | 字典项变更时清除 |
| 系统参数 | system:param:{key} | 30分钟 | 参数变更时清除 |
| 文件信息 | system:file:{id} | 24小时 | 文件删除时清除 |

### 4.2 缓存预热

```java
@Component
public class CacheWarmUpService {
    
    @Autowired
    private SystemDictCacheService dictCacheService;
    
    @Autowired
    private SystemParamCacheService paramCacheService;
    
    /**
     * 缓存预热
     */
    @PostConstruct
    public void warmUp() {
        // 预热常用字典
        List<String> commonDictCodes = Arrays.asList(
            "common_status", "common_gender", "common_yes_no"
        );
        
        for (String dictCode : commonDictCodes) {
            dictCacheService.getDictByCode(dictCode);
            dictCacheService.getDictItemsByCode(dictCode);
        }
        
        // 预热系统参数
        List<String> commonParamKeys = Arrays.asList(
            "system.name", "system.version", "system.copyright"
        );
        
        for (String paramKey : commonParamKeys) {
            paramCacheService.getParamValue(paramKey);
        }
    }
}
```

## 5. 性能优化

### 5.1 数据库优化

#### 索引设计

```sql
-- system_dict表索引
CREATE INDEX idx_dict_code ON system_dict(code);
CREATE INDEX idx_dict_type ON system_dict(dict_type);

-- system_dict_item表索引
CREATE INDEX idx_dict_item_dict_id ON system_dict_item(dict_id);
CREATE INDEX idx_dict_item_value ON system_dict_item(item_value);

-- system_param表索引
CREATE INDEX idx_param_key ON system_param(param_key);
CREATE INDEX idx_param_group ON system_param(param_group);

-- system_file表索引
CREATE INDEX idx_file_md5 ON system_file(md5);
CREATE INDEX idx_file_uploader ON system_file(uploader);
CREATE INDEX idx_file_created_time ON system_file(created_time);

-- system_log表索引
CREATE INDEX idx_log_user_id ON system_log(user_id);
CREATE INDEX idx_log_log_type ON system_log(log_type);
CREATE INDEX idx_log_created_time ON system_log(created_time);
CREATE INDEX idx_log_module ON system_log(module);
```

#### 分区表设计

```sql
-- 按月分区日志表
CREATE TABLE system_log (
    id BIGSERIAL,
    log_type VARCHAR(20),
    module VARCHAR(50),
    user_id BIGINT,
    created_time TIMESTAMP,
    -- 其他字段...
) PARTITION BY RANGE (created_time);

-- 创建分区
CREATE TABLE system_log_202501 PARTITION OF system_log
    FOR VALUES FROM ('2025-01-01') TO ('2025-02-01');

CREATE TABLE system_log_202502 PARTITION OF system_log
    FOR VALUES FROM ('2025-02-01') TO ('2025-03-01');
```

### 5.2 文件上传优化

#### 文件分片上传

```java
@Service
public class FileChunkServiceImpl implements FileChunkService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CHUNK_CACHE_KEY = "file:chunk:";
    
    /**
     * 上传文件分片
     */
    @Override
    public void uploadChunk(String fileId, Integer chunkNumber, MultipartFile chunk) throws IOException {
        String chunkKey = CHUNK_CACHE_KEY + fileId + ":" + chunkNumber;
        byte[] chunkData = chunk.getBytes();
        redisTemplate.opsForValue().set(chunkKey, chunkData, 1, TimeUnit.HOURS);
    }
    
    /**
     * 合并文件分片
     */
    @Override
    public String mergeChunks(String fileId, String fileName, Integer totalChunks) throws IOException {
        // 创建临时文件
        File tempFile = File.createTempFile("merge_", "_" + fileName);
        
        // 合并分片
        try (FileOutputStream fos = new FileOutputStream(tempFile)) {
            for (int i = 1; i <= totalChunks; i++) {
                String chunkKey = CHUNK_CACHE_KEY + fileId + ":" + i;
                byte[] chunkData = (byte[]) redisTemplate.opsForValue().get(chunkKey);
                if (chunkData != null) {
                    fos.write(chunkData);
                    redisTemplate.delete(chunkKey);
                }
            }
        }
        
        // 上传合并后的文件
        MultipartFile mergedFile = new MockMultipartFile(fileName, tempFile.getName(), 
            Files.probeContentType(tempFile.toPath()), Files.readAllBytes(tempFile.toPath()));
        
        String filePath = fileStorageStrategy.upload(mergedFile, "common", 
            DateTimeUtils.format(new Date(), "yyyy/MM/dd"));
        
        // 删除临时文件
        tempFile.delete();
        
        return filePath;
    }
}
```

## 6. 安全设计

### 6.1 文件安全

#### 文件类型校验

```java
@Component
public class FileSecurityValidator {
    
    private static final Set<String> ALLOWED_IMAGE_TYPES = new HashSet<>(Arrays.asList(
        "image/jpeg", "image/png", "image/gif", "image/webp"
    ));
    
    private static final Set<String> ALLOWED_DOCUMENT_TYPES = new HashSet<>(Arrays.asList(
        "application/pdf",
        "application/msword",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
        "application/vnd.ms-excel",
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
    ));
    
    /**
     * 校验文件类型
     */
    public void validateFileType(String mimeType) {
        boolean isAllowed = ALLOWED_IMAGE_TYPES.contains(mimeType) 
            || ALLOWED_DOCUMENT_TYPES.contains(mimeType);
        
        if (!isAllowed) {
            throw new BusinessException("不支持的文件类型: " + mimeType);
        }
    }
    
    /**
     * 校验文件内容
     */
    public void validateFileContent(MultipartFile file) throws IOException {
        // 检查文件头信息，防止伪造文件类型
        String fileType = FileTypeUtil.getType(file.getInputStream());
        String mimeType = file.getContentType();
        
        // 简单验证：图片文件必须有图片头
        if (mimeType.startsWith("image/") && !fileType.startsWith("image")) {
            throw new BusinessException("文件内容与扩展名不匹配");
        }
    }
}
```

### 6.2 敏感参数加密

```java
@Component
public class SensitiveParamEncryptor {
    
    @Value("${param.encrypt.key}")
    private String encryptKey;
    
    /**
     * 加密敏感参数
     */
    public String encrypt(String value) {
        try {
            return CryptoUtils.aesEncrypt(value, encryptKey);
        } catch (Exception e) {
            throw new BusinessException("参数加密失败: " + e.getMessage());
        }
    }
    
    /**
     * 解密敏感参数
     */
    public String decrypt(String encryptedValue) {
        try {
            return CryptoUtils.aesDecrypt(encryptedValue, encryptKey);
        } catch (Exception e) {
            throw new BusinessException("参数解密失败: " + e.getMessage());
        }
    }
}
```

## 7. 部署配置

### 7.1 application.yml

```yaml
server:
  port: 8084

spring:
  application:
    name: qooerp-system
  
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://localhost:5432/qooerp
    username: postgres
    password: postgres
  
  redis:
    host: localhost
    port: 6379
    database: 3
    password:
  
  servlet:
    multipart:
      max-file-size: 10MB
      max-request-size: 50MB
  
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: qooerp
      config:
        server-addr: localhost:8848
        namespace: qooerp
        file-extension: yml

# 文件配置
file:
  upload:
    path: /data/qooerp/files
  access:
    url: /file

# 阿里云OSS配置
aliyun:
  oss:
    endpoint: oss-cn-hangzhou.aliyuncs.com
    access-key-id: ${OSS_ACCESS_KEY_ID}
    access-key-secret: ${OSS_ACCESS_KEY_SECRET}
    bucket-name: qooerp-files

mybatis-plus:
  mapper-locations: classpath*:mapper/**/*.xml
  type-aliases-package: com.qoobot.qooerp.system.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

# 定时任务配置
quartz:
  enabled: true
  auto-startup: true

logging:
  level:
    com.qoobot.qooerp.system: debug
  file:
    name: /data/qooerp/logs/system.log
    max-size: 100MB
    max-history: 30
```

### 7.2 环境变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| SERVER_PORT | 服务端口 | 8084 |
| DB_URL | 数据库URL | - |
| DB_USERNAME | 数据库用户名 | - |
| DB_PASSWORD | 数据库密码 | - |
| REDIS_HOST | Redis主机 | localhost |
| REDIS_PORT | Redis端口 | 6379 |
| NACOS_ADDR | Nacos地址 | localhost:8848 |
| OSS_ACCESS_KEY_ID | OSS AccessKey | - |
| OSS_ACCESS_KEY_SECRET | OSS AccessSecret | - |

## 8. 版本历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0.0 | 2025-01-17 | 初始版本 | Auto |
