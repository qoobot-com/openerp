# QooERP 生产管理模块 - 技术设计文档

> 模块名称: qooerp-production
> 模块版本: v1.0
> 创建日期: 2026-02-17
> 作者: Auto
> **数据库**: PostgreSQL 15+

---

## 一、技术栈

### 1.1 后端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Spring Boot | 3.2.x | 核心框架 |
| Spring Cloud | 2023.x | 微服务框架 |
| MyBatis-Plus | 3.5.x | ORM框架 |
| PostgreSQL | 15+ | 数据库 |
| Redis | 7.x | 缓存 |
| Nacos | 2.x | 服务注册与配置中心 |
| Sentinel | 1.8.x | 限流熔断 |
| OpenFeign | 4.x | 服务调用 |
| Hutool | 5.x | 工具类库 |

### 1.2 前端技术栈

| 技术 | 版本 | 说明 |
|------|------|------|
| Vue 3 | 3.x | 前端框架 |
| Element Plus | Latest | UI组件库 |
| TypeScript | 5.x | 类型系统 |
| Axios | Latest | HTTP客户端 |
| Pinia | Latest | 状态管理 |

---

## 二、架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                      Client Layer                       │
│  (Web Browser / Mobile App / Third-party System)        │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                   API Gateway                           │
│  (Spring Cloud Gateway + Sentinel + JWT)                │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│            Production Service                           │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Controller Layer                                │   │
│  │  - RESTful API                                  │   │
│  │  - Parameter Validation                         │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Service Layer                                   │   │
│  │  - Business Logic                                │   │
│  │  - Domain Model                                 │   │
│  │  - Event Handling                                │   │
│  └──────────────────────────────────────────────────┘   │
│  ┌──────────────────────────────────────────────────┐   │
│  │  Data Access Layer                              │   │
│  │  - MyBatis-Plus                                  │   │
│  │  - Entity Mapping                                │   │
│  └──────────────────────────────────────────────────┘   │
└──────────────────────┬──────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
┌───────▼─────┐ ┌─────▼──────┐ ┌──────▼──────┐
│ PostgreSQL  │ │   Redis    │ │    Nacos    │
│  Database   │ │   Cache    │ │   Config    │
└─────────────┘ └────────────┘ └─────────────┘
```

### 2.2 依赖服务

| 服务名 | 说明 | 调用方式 |
|--------|------|---------|
| qooerp-inventory | 库存服务 | Feign |
| qooerp-sales | 销售服务 | Feign |
| qooerp-purchase | 采购服务 | Feign |
| qooerp-organization | 组织服务 | Feign |

---

## 三、核心功能实现

### 3.1 物料需求计划(MRP)实现

```java
/**
 * 物料需求计划计算服务
 */
@Service
public class MRPService {
    
    @Autowired
    private ProductionBomMapper bomMapper;
    
    @Autowired
    private InventoryServiceClient inventoryService;
    
    /**
     * 计算物料需求
     */
    public List<MaterialRequirementDTO> calculateMRP(Long planId, 
        BigDecimal productionQuantity) {
        
        // 1. 获取产品BOM
        List<ProductionBom> bomList = bomMapper.selectByProductId(
            productId
        );
        
        // 2. 计算物料需求
        List<MaterialRequirementDTO> requirements = new ArrayList<>();
        for (ProductionBom bom : bomList) {
            BigDecimal requiredQty = bom.getQuantity()
                .multiply(productionQuantity);
            
            // 3. 获取当前库存
            InventoryDTO inventory = inventoryService
                .getStock(bom.getMaterialId()).getData();
            
            BigDecimal shortageQty = requiredQty
                .subtract(inventory.getQuantity());
            if (shortageQty.compareTo(BigDecimal.ZERO) > 0) {
                // 4. 生成采购需求
                requirements.add(MaterialRequirementDTO.builder()
                    .materialId(bom.getMaterialId())
                    .materialCode(bom.getMaterialCode())
                    .materialName(bom.getMaterialName())
                    .requiredQuantity(requiredQty)
                    .currentStock(inventory.getQuantity())
                    .shortageQuantity(shortageQty)
                    .build());
            }
        }
        
        return requirements;
    }
}
```

### 3.2 生产进度跟踪实现

```java
/**
 * 生产进度跟踪服务
 */
@Service
public class OrderProgressService {
    
    @Autowired
    private ProductionOrderMapper orderMapper;
    
    @Autowired
    private ProductionReportMapper reportMapper;
    
    /**
     * 获取订单进度
     */
    public OrderProgressDTO getProgress(Long orderId) {
        ProductionOrder order = orderMapper.selectById(orderId);
        
        // 1. 统计完成数量
        BigDecimal completedQty = reportMapper.sumCompletedQuantity(orderId);
        
        // 2. 计算进度百分比
        BigDecimal progress = BigDecimal.ZERO;
        if (order.getOrderQuantity().compareTo(BigDecimal.ZERO) > 0) {
            progress = completedQty.divide(order.getOrderQuantity(), 
                4, RoundingMode.HALF_UP)
                .multiply(new BigDecimal("100"));
        }
        
        // 3. 统计工时
        BigDecimal totalWorkHours = reportMapper.sumWorkHours(orderId);
        
        return OrderProgressDTO.builder()
            .orderId(order.getId())
            .orderNo(order.getOrderNo())
            .status(order.getStatus())
            .completedQuantity(completedQty)
            .progress(progress)
            .totalWorkHours(totalWorkHours)
            .build();
    }
}
```

### 3.3 领料出库实现

```java
/**
 * 领料出库服务
 */
@Service
public class MaterialIssueService {
    
    @Autowired
    private ProductionMaterialMapper materialMapper;
    
    @Autowired
    private InventoryServiceClient inventoryService;
    
    /**
     * 领料出库
     */
    @Transactional(rollbackFor = Exception.class)
    public void issueMaterial(Long materialId) {
        ProductionMaterial material = materialMapper.selectById(materialId);
        
        // 1. 检查库存
        InventoryDTO inventory = inventoryService
            .getStock(material.getMaterialId()).getData();
        
        if (inventory.getQuantity().compareTo(
            material.getRequestQuantity()) < 0) {
            throw new BusinessException("库存不足");
        }
        
        // 2. 扣减库存
        inventoryService.deductStock(StockDeductDTO.builder()
            .materialId(material.getMaterialId())
            .quantity(material.getRequestQuantity())
            .businessNo(material.getMaterialNo())
            .businessType("PRODUCTION_ISSUE")
            .build());
        
        // 3. 更新领料状态
        material.setIssuedQuantity(material.getRequestQuantity());
        material.setStatus(MaterialStatus.ISSUED);
        material.setIssueDate(LocalDate.now());
        materialMapper.updateById(material);
        
        // 4. 发布事件
        eventPublisher.publishEvent(
            ProductionMaterialIssuedEvent.builder()
                .materialId(materialId)
                .orderId(material.getOrderId())
                .materialCode(material.getMaterialCode())
                .quantity(material.getIssuedQuantity())
                .build()
        );
    }
}
```

---

## 四、性能优化

### 4.1 数据库优化

#### 4.1.1 索引优化

```sql
-- 生产订单表索引
CREATE INDEX idx_order_status ON production_order(status);
CREATE INDEX idx_order_date ON production_order(order_date);
CREATE INDEX idx_order_product ON production_order(product_id);

-- 生产领料表索引
CREATE INDEX idx_material_order ON production_material(order_id);
CREATE INDEX idx_material_status ON production_material(status);

-- 生产入库表索引
CREATE INDEX idx_receipt_order ON production_receipt(order_id);
CREATE INDEX idx_receipt_date ON production_receipt(receipt_date);
```

#### 4.1.2 分区表

```sql
-- 按日期分区生产报工表
ALTER TABLE production_report 
PARTITION BY RANGE (TO_DAYS(work_date)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01')),
    PARTITION p202602 VALUES LESS THAN (TO_DAYS('2026-03-01')),
    PARTITION p202603 VALUES LESS THAN (TO_DAYS('2026-04-01')),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

### 4.2 缓存优化

#### 4.2.1 多级缓存

```java
@Configuration
public class CacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration
            .defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(
                RedisSerializationContext.SerializationPair
                    .fromSerializer(new StringRedisSerializer())
            )
            .serializeValuesWith(
                RedisSerializationContext.SerializationPair
                    .fromSerializer(new GenericJackson2JsonRedisSerializer())
            );
        
        Map<String, RedisCacheConfiguration> cacheConfigurations = 
            new HashMap<>();
        
        // 生产计划缓存 - 1小时
        cacheConfigurations.put("production:plan", 
            config.entryTtl(Duration.ofHours(1)));
        
        // 生产订单缓存 - 30分钟
        cacheConfigurations.put("production:order", 
            config.entryTtl(Duration.ofMinutes(30)));
        
        // 生产物料缓存 - 15分钟
        cacheConfigurations.put("production:material", 
            config.entryTtl(Duration.ofMinutes(15)));
        
        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .withInitialCacheConfigurations(cacheConfigurations)
            .build();
    }
}
```

### 4.3 查询优化

```java
/**
 * 分页查询优化
 */
@Service
public class ProductionQueryService {
    
    /**
     * 分页查询生产订单
     */
    public Page<ProductionOrderDTO> listOrders(PageParam pageParam,
        ProductionOrderQueryParam queryParam) {
        
        // 1. 使用MyBatis-Plus分页
        Page<ProductionOrder> page = new Page<>(pageParam.getPage(), 
            pageParam.getSize());
        
        // 2. 构建查询条件
        LambdaQueryWrapper<ProductionOrder> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(StringUtils.isNotBlank(queryParam.getOrderNo()),
            ProductionOrder::getOrderNo, queryParam.getOrderNo())
            .eq(queryParam.getStatus() != null,
                ProductionOrder::getStatus, queryParam.getStatus())
            .orderByDesc(ProductionOrder::getCreateTime);
        
        // 3. 执行查询
        Page<ProductionOrder> result = orderMapper.selectPage(page, wrapper);
        
        // 4. 转换DTO
        return result.convert(order -> convertToDTO(order));
    }
}
```

---

## 五、安全性设计

### 5.1 数据权限控制

```java
/**
 * 数据权限拦截器
 */
@Component
public class ProductionDataPermissionInterceptor 
    implements Interceptor {
    
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        
        // 1. 获取当前用户
        Long userId = SecurityContextHolder.getCurrentUserId();
        
        // 2. 检查数据权限
        if (!hasDataPermission(userId, invocation.getArgs())) {
            throw new ForbiddenException("无权访问该数据");
        }
        
        return invocation.proceed();
    }
    
    private boolean hasDataPermission(Long userId, Object[] args) {
        // 实现数据权限检查逻辑
        return true;
    }
}
```

### 5.2 操作日志

```java
/**
 * 操作日志切面
 */
@Aspect
@Component
public class ProductionLogAspect {
    
    @Autowired
    private OperationLogService logService;
    
    @Around("@annotation(productionLog)")
    public Object logAround(ProceedingJoinPoint joinPoint,
        ProductionLog productionLog) throws Throwable {
        
        long startTime = System.currentTimeMillis();
        Object result = null;
        Exception exception = null;
        
        try {
            result = joinPoint.proceed();
            return result;
        } catch (Exception e) {
            exception = e;
            throw e;
        } finally {
            long duration = System.currentTimeMillis() - startTime;
            
            // 记录操作日志
            logService.saveLog(OperationLog.builder()
                .module("PRODUCTION")
                .operation(productionLog.value())
                .method(joinPoint.getSignature().getName())
                .duration(duration)
                .success(exception == null)
                .errorMessage(exception != null ? 
                    exception.getMessage() : null)
                .build());
        }
    }
}
```

---

## 六、配置管理

### 6.1 Nacos配置

```yaml
# application.yml
spring:
  cloud:
    nacos:
      config:
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
        file-extension: yml
        shared-configs:
          - data-id: qooerp-common.yml
            refresh: true
      discovery:
        server-addr: ${NACOS_HOST:localhost}:${NACOS_PORT:8848}
```

```yaml
# bootstrap.yml
spring:
  application:
    name: qooerp-production
  profiles:
    active: ${SPRING_PROFILES_ACTIVE:dev}
```

### 6.2 环境变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| SPRING_PROFILES_ACTIVE | 环境配置 | dev |
| NACOS_HOST | Nacos地址 | localhost |
| NACOS_PORT | Nacos端口 | 8848 |
| DB_HOST | 数据库地址 | localhost |
| DB_PORT | 数据库端口 | 3306 |
| DB_NAME | 数据库名称 | qooerp_production |
| REDIS_HOST | Redis地址 | localhost |
| REDIS_PORT | Redis端口 | 6379 |

---

## 七、部署配置

### 7.1 Docker部署

```dockerfile
FROM openjdk:17-jdk-slim

LABEL maintainer="qoobot"
LABEL description="QooERP Production Service"

WORKDIR /app

# 设置时区
ENV TZ=Asia/Shanghai
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# 复制JAR文件
COPY qooerp-production-start/target/qooerp-production-start-1.0.0.jar app.jar

# JVM参数
ENV JAVA_OPTS="-Xms512m -Xmx1024m -XX:+UseG1GC"

# 暴露端口
EXPOSE 8092

# 健康检查
HEALTHCHECK --interval=30s --timeout=3s --retries=3 \
  CMD curl -f http://localhost:8092/actuator/health | exit 1

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar /app.jar"]
```

### 7.2 Kubernetes部署

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: qooerp-production
  namespace: qooerp
spec:
  replicas: 2
  selector:
    matchLabels:
      app: qooerp-production
  template:
    metadata:
      labels:
        app: qooerp-production
    spec:
      containers:
      - name: qooerp-production
        image: qoobot/qooerp-production:1.0.0
        ports:
        - containerPort: 8092
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: NACOS_HOST
          value: "nacos.qooerp.svc.cluster.local"
        - name: DB_HOST
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: host
        resources:
          requests:
            memory: "512Mi"
            cpu: "500m"
          limits:
            memory: "1Gi"
            cpu: "1000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8092
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8092
          initialDelaySeconds: 30
          periodSeconds: 10
---
apiVersion: v1
kind: Service
metadata:
  name: qooerp-production
  namespace: qooerp
spec:
  selector:
    app: qooerp-production
  ports:
  - protocol: TCP
    port: 8092
    targetPort: 8092
  type: ClusterIP
```

---

## 八、监控告警

### 8.1 Actuator配置

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

### 8.2 监控指标

| 指标名称 | 说明 | 告警阈值 |
|---------|------|---------|
| production_order_count | 生产订单数量 | - |
| production_order_duration | 订单处理时长 | > 30分钟 |
| production_material_issue_rate | 领料成功率 | < 95% |
| production_receipt_quality_rate | 质检合格率 | < 98% |

---

**文档版本**: v1.0
**最后更新**: 2026-02-17
**数据库**: PostgreSQL 15+
