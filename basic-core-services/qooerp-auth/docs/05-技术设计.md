# QooERP Auth 模块 - 技术设计文档

## 1. 技术选型

### 1.1 核心技术栈

| 技术组件 | 版本 | 用途 |
|---------|------|------|
| Spring Boot | 3.x | 应用框架 |
| Spring Security | 6.x | 安全框架 |
| MyBatis-Plus | 3.5.x | ORM框架 |
| PostgreSQL | 15+ | 关系型数据库 |
| Redis | 7.x | 缓存数据库 |
| Nacos | 2.x | 配置中心和服务发现 |
| Sentinel | 1.8.x | 限流熔断 |
| Spring Cloud OpenFeign | 4.x | 服务调用 |

### 1.2 前端技术栈

| 技术组件 | 版本 | 用途 |
|---------|------|------|
| Vue 3 | 3.x | 前端框架 |
| TDesign | Latest | UI 组件库 (PC+Mobile) |
| Electron | Latest | 桌面应用打包 |
| Capacitor | Latest | 移动应用打包 |
| TypeScript | 5.x | 类型系统 |
| Axios | Latest | HTTP 客户端 |
| Pinia | Latest | 状态管理 |
| Vite | 5.x | 构建工具 |

#### 前端架构说明

本项目采用**前后端分离架构**，所有微服务统一使用 `qooerp-frontend` 作为前端工程，通过 RESTful API 调用后端服务。

**前端工程结构**：
- 前端代码仓库：`qooerp-frontend`
- API 调用示例：前端 API 文件位于 `src/api/auth.ts`
- 统一通过 API Gateway (qooerp-gateway) 访问后端服务

**多端支持**：
- PC 端：TDesign Vue Next
- 移动端：TDesign Mobile
- 桌面应用：Electron 打包
- 移动应用：Capacitor 打包（支持 iOS/Android）

**前端 API 封装示例**：
```typescript
// qooerp-frontend/packages/web/src/api/auth.ts
import request from '@/utils/request'

export const authApi = {
  // 用户名密码登录
  login: (data: LoginRequest) => {
    return request.post<LoginResponse>('/api/auth/login', data)
  },

  // 验证码登录
  loginWithCaptcha: (data: CaptchaLoginRequest) => {
    return request.post<LoginResponse>('/api/auth/login/captcha', data)
  },

  // 刷新 Token
  refreshToken: (data: RefreshTokenRequest) => {
    return request.post<TokenResponse>('/api/auth/refresh', data)
  },

  // 登出
  logout: () => {
    return request.post<void>('/api/auth/logout')
  },

  // 获取验证码
  getCaptcha: () => {
    return request.get<CaptchaResponse>('/api/auth/captcha')
  },

  // MFA 设置
  mfaSetup: () => {
    return request.post<MfaSetupResponse>('/api/auth/mfa/setup')
  },

  // MFA 验证
  mfaVerify: (code: string) => {
    return request.post<void>('/api/auth/mfa/verify', { code })
  },

  // 第三方登录
  thirdPartyLogin: (data: ThirdPartyLoginRequest) => {
    return request.post<LoginResponse>('/api/auth/third-party/login', data)
  }
}
```

### 1.3 依赖模块

```xml
<dependencies>
    <!-- 公共模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-api</artifactId>
    </dependency>
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-core</artifactId>
    </dependency>
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-common-security</artifactId>
    </dependency>
    
    <!-- 用户模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-user-api</artifactId>
    </dependency>
    
    <!-- 组织模块 -->
    <dependency>
        <groupId>com.qoobot</groupId>
        <artifactId>qooerp-organization-api</artifactId>
    </dependency>
    
    <!-- 数据库 -->
    <dependency>
        <groupId>org.postgresql</groupId>
        <artifactId>postgresql</artifactId>
    </dependency>
    
    <!-- 缓存 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- 注册中心和配置中心 -->
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-discovery</artifactId>
    </dependency>
    <dependency>
        <groupId>com.alibaba.cloud</groupId>
        <artifactId>spring-cloud-starter-alibaba-nacos-config</artifactId>
    </dependency>
    
    <!-- JWT -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId>
    </dependency>
    
    <!-- 验证码 -->
    <dependency>
        <groupId>com.github.penggle</groupId>
        <artifactId>kaptcha</artifactId>
    </dependency>
    
    <!-- MFA -->
    <dependency>
        <groupId>com.warrenstrange</groupId>
        <artifactId>googleauth</artifactId>
    </dependency>
</dependencies>
```

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   客户端层 (Web/Mobile)                   │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                    API Gateway                            │
│              (路由、认证、限流)                            │
└──────────────────────┬──────────────────────────────────┘
                       │
┌──────────────────────▼──────────────────────────────────┐
│                  Auth Service                            │
│  ┌────────────────────────────────────────────────────┐  │
│  │              Controller 层                         │  │
│  │  - AuthController                                   │  │
│  │  - CaptchaController                                │  │
│  │  - MfaController                                    │  │
│  │  - DeviceController                                 │  │
│  │  - ThirdPartyLoginController                        │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              Service 层                             │  │
│  │  - AuthService                                      │  │
│  │  - TokenService                                     │  │
│  │  - CaptchaService                                   │  │
│  │  - MfaService                                       │  │
│  │  - DeviceService                                    │  │
│  │  - ThirdPartyLoginService                           │  │
│  │  - LoginLogService                                  │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              Strategy 层 (登录策略)                  │  │
│  │  - UsernamePasswordLoginStrategy                    │  │
│  │  - SmsLoginStrategy                                 │  │
│  │  - EmailLoginStrategy                               │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              Mapper 层                              │  │
│  │  - AuthUserMapper                                   │  │
│  │  - AuthDeviceMapper                                 │  │
│  │  - AuthLoginLogMapper                               │  │
│  │  - AuthThirdPartyMapper                             │  │
│  └──────────────────────┬─────────────────────────────┘  │
│  ┌──────────────────────▼─────────────────────────────┐  │
│  │              数据访问层                             │  │
│  │  - MyBatis-Plus                                     │  │
│  └────────────────────────────────────────────────────┘  │
└──────────────────────┬──────────────────────────────────┘
                       │
        ┌──────────────┼──────────────┐
        │              │              │
┌───────▼──────┐ ┌─────▼─────┐ ┌────▼─────┐
│  PostgreSQL  │ │   Redis   │ │  Nacos   │
│   (持久化)   │ │  (缓存)   │ │(配置中心) │
└──────────────┘ └───────────┘ └──────────┘
```

### 2.2 分层架构详解

#### Controller 层
- 职责：接收HTTP请求，参数校验，调用Service层，返回响应
- 特性：统一异常处理，统一响应格式，操作日志记录

#### Service 层
- 职责：业务逻辑处理，事务管理，缓存管理
- 特性：接口与实现分离，使用@Transactional注解管理事务

#### Strategy 层
- 职责：实现不同的登录策略（用户名密码、短信、邮箱、第三方登录）
- 特性：策略模式 + 工厂模式，易于扩展新的登录方式

#### Mapper 层
- 职责：数据库访问，SQL映射
- 特性：继承MyBatis-Plus的BaseMapper，支持通用CRUD

## 3. 核心功能实现

### 3.1 JWT Token 认证

#### Token 生成与验证

```java
@Service
public class TokenServiceImpl implements TokenService {
    
    private static final String SECRET_KEY = "your-secret-key";
    private static final long ACCESS_TOKEN_EXPIRATION = 7200; // 2小时
    private static final long REFRESH_TOKEN_EXPIRATION = 604800; // 7天
    
    @Override
    public String generateAccessToken(Long userId, String username) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + ACCESS_TOKEN_EXPIRATION * 1000);
        
        return Jwts.builder()
                .subject(userId.toString())
                .claim("username", username)
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }
    
    @Override
    public String generateRefreshToken(Long userId) {
        Date now = new Date();
        Date expiryDate = new Date(now.getTime() + REFRESH_TOKEN_EXPIRATION * 1000);
        
        return Jwts.builder()
                .subject(userId.toString())
                .claim("type", "refresh")
                .issuedAt(now)
                .expiration(expiryDate)
                .signWith(getSigningKey())
                .compact();
    }
    
    @Override
    public Claims parseToken(String token) {
        return Jwts.parser()
                .verifyWith(getSigningKey())
                .build()
                .parseSignedClaims(token)
                .getPayload();
    }
    
    private SecretKey getSigningKey() {
        byte[] keyBytes = Decoders.BASE64.decode(SECRET_KEY);
        return Keys.hmacShaKeyFor(keyBytes);
    }
}
```

### 3.2 登录策略模式

#### 策略接口定义

```java
public interface LoginStrategy {
    
    /**
     * 执行登录
     */
    LoginResponse login(LoginRequest request);
    
    /**
     * 获取登录类型
     */
    LoginType getLoginType();
}
```

#### 策略工厂

```java
@Component
public class LoginStrategyFactory {
    
    @Autowired
    private Map<String, LoginStrategy> strategyMap;
    
    public LoginStrategy getStrategy(LoginType loginType) {
        String beanName = loginType.name().toLowerCase() + "LoginStrategy";
        LoginStrategy strategy = strategyMap.get(beanName);
        if (strategy == null) {
            throw new AuthException("不支持的登录方式: " + loginType);
        }
        return strategy;
    }
}
```

#### 用户名密码登录策略实现

```java
@Component("usernamePasswordLoginStrategy")
public class UsernamePasswordLoginStrategy implements LoginStrategy {
    
    @Autowired
    private AuthUserMapper authUserMapper;
    
    @Autowired
    private PasswordEncoder passwordEncoder;
    
    @Autowired
    private TokenService tokenService;
    
    @Override
    public LoginResponse login(LoginRequest request) {
        // 1. 查询用户
        AuthUser authUser = authUserMapper.selectByUsername(request.getUsername());
        if (authUser == null) {
            throw new LoginFailedException("用户名或密码错误");
        }
        
        // 2. 验证密码
        if (!passwordEncoder.matches(request.getPassword(), authUser.getPassword())) {
            // 记录失败次数
            recordLoginFailure(authUser);
            throw new LoginFailedException("用户名或密码错误");
        }
        
        // 3. 检查账户状态
        if (authUser.getStatus() == UserStatus.LOCKED) {
            throw new UserLockedException("账户已被锁定");
        }
        
        // 4. 生成 Token
        String accessToken = tokenService.generateAccessToken(authUser.getUserId(), authUser.getUsername());
        String refreshToken = tokenService.generateRefreshToken(authUser.getUserId());
        
        // 5. 记录登录日志
        recordLoginLog(authUser, true);
        
        // 6. 清除失败次数
        clearLoginFailure(authUser);
        
        return LoginResponse.builder()
                .accessToken(accessToken)
                .refreshToken(refreshToken)
                .userId(authUser.getUserId())
                .username(authUser.getUsername())
                .build();
    }
    
    @Override
    public LoginType getLoginType() {
        return LoginType.USERNAME_PASSWORD;
    }
}
```

### 3.3 验证码生成与验证

#### 图形验证码

```java
@Service
public class CaptchaServiceImpl implements CaptchaService {
    
    @Autowired
    private Producer captchaProducer;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    private static final String CAPTCHA_KEY_PREFIX = "captcha:";
    private static final int CAPTCHA_EXPIRE_SECONDS = 300; // 5分钟
    
    @Override
    public CaptchaResponse generateCaptcha() {
        // 生成验证码文本
        String captchaText = captchaProducer.createText();
        
        // 生成验证码图片
        BufferedImage captchaImage = captchaProducer.createImage(captchaText);
        
        // 转换为 Base64
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(captchaImage, "png", baos);
        String captchaBase64 = Base64.getEncoder().encodeToString(baos.toByteArray());
        
        // 存储到 Redis
        String captchaId = UUID.randomUUID().toString();
        String captchaKey = CAPTCHA_KEY_PREFIX + captchaId;
        redisTemplate.opsForValue().set(captchaKey, captchaText.toLowerCase(), 
                                        CAPTCHA_EXPIRE_SECONDS, TimeUnit.SECONDS);
        
        return CaptchaResponse.builder()
                .captchaId(captchaId)
                .captchaImage("data:image/png;base64," + captchaBase64)
                .expireSeconds(CAPTCHA_EXPIRE_SECONDS)
                .build();
    }
    
    @Override
    public boolean verifyCaptcha(String captchaId, String captchaCode) {
        String captchaKey = CAPTCHA_KEY_PREFIX + captchaId;
        String storedCode = (String) redisTemplate.opsForValue().get(captchaKey);
        
        if (storedCode == null) {
            return false;
        }
        
        boolean valid = storedCode.equalsIgnoreCase(captchaCode);
        
        // 验证后删除验证码
        redisTemplate.delete(captchaKey);
        
        return valid;
    }
}
```

### 3.4 MFA 双因素认证

#### MFA 设置

```java
@Service
public class MfaServiceImpl implements MfaService {
    
    @Autowired
    private GoogleAuthenticator gAuth;
    
    @Autowired
    private AuthUserMapper authUserMapper;
    
    @Override
    public MfaSetupResponse setupMfa(Long userId) {
        // 生成密钥
        String secret = GoogleAuthenticator.generateRandomKey();
        
        // 生成二维码 URL
        GoogleAuthenticatorKey gKey = new GoogleAuthenticatorKey.Builder(secret).build();
        String qrUrl = GoogleAuthenticatorQRGenerator.getOtpAuthTotpURL(
                "QooERP", 
                String.valueOf(userId), 
                gKey);
        
        return MfaSetupResponse.builder()
                .secret(secret)
                .qrUrl(qrUrl)
                .build();
    }
    
    @Override
    public boolean verifyCode(Long userId, String code, String secret) {
        GoogleAuthenticatorKey gKey = new GoogleAuthenticatorKey.Builder(secret).build();
        return gAuth.authorize(gKey, Integer.parseInt(code));
    }
}
```

### 3.5 第三方登录

#### OAuth2 第三方登录流程

```java
@Service
public class ThirdPartyLoginServiceImpl implements ThirdPartyLoginService {
    
    @Autowired
    private RestTemplate restTemplate;
    
    @Autowired
    private AuthUserMapper authUserMapper;
    
    @Autowired
    private TokenService tokenService;
    
    @Override
    public LoginResponse loginWithThirdParty(ThirdPartyLoginRequest request) {
        // 1. 根据 platform 获取访问令牌
        String accessToken = getAccessToken(request.getPlatform(), request.getAuthCode());
        
        // 2. 获取第三方用户信息
        ThirdPartyUserInfo userInfo = getThirdPartyUserInfo(request.getPlatform(), accessToken);
        
        // 3. 查询或创建绑定关系
        AuthThirdParty authThirdParty = authUserMapper.selectByThirdPartyId(
                request.getPlatform(), userInfo.getId());
        
        Long userId;
        if (authThirdParty == null) {
            // 创建新用户
            userId = createUserFromThirdParty(request.getPlatform(), userInfo);
        } else {
            userId = authThirdParty.getUserId();
        }
        
        // 4. 生成 Token
        AuthUser authUser = authUserMapper.selectByUserId(userId);
        String accessTokenToken = tokenService.generateAccessToken(userId, authUser.getUsername());
        String refreshToken = tokenService.generateRefreshToken(userId);
        
        return LoginResponse.builder()
                .accessToken(accessTokenToken)
                .refreshToken(refreshToken)
                .userId(userId)
                .username(authUser.getUsername())
                .build();
    }
}
```

### 3.6 设备管理

#### 设备绑定与管理

```java
@Service
public class DeviceServiceImpl implements DeviceService {
    
    @Autowired
    private AuthDeviceMapper deviceMapper;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public void bindDevice(Long userId, String deviceInfo) {
        // 解析设备信息
        String deviceId = parseDeviceId(deviceInfo);
        String deviceType = parseDeviceType(deviceInfo);
        
        // 检查设备数量限制
        long deviceCount = deviceMapper.countByUserId(userId);
        if (deviceCount >= 5) {
            throw new AuthException("设备数量已达上限");
        }
        
        // 保存设备信息
        AuthDevice device = new AuthDevice();
        device.setUserId(userId);
        device.setDeviceId(deviceId);
        device.setDeviceType(deviceType);
        device.setDeviceInfo(deviceInfo);
        device.setLastLoginTime(new Date());
        device.setStatus(DeviceStatus.ACTIVE);
        
        deviceMapper.insert(device);
    }
    
    @Override
    public List<AuthDevice> getUserDevices(Long userId) {
        return deviceMapper.selectByUserId(userId);
    }
    
    @Override
    public void revokeDevice(Long userId, Long deviceId) {
        deviceMapper.updateStatus(userId, deviceId, DeviceStatus.REVOKED);
        
        // 清除该设备的 Token
        clearDeviceToken(userId, deviceId);
    }
}
```

## 4. 缓存设计

### 4.1 缓存策略

| 数据类型 | 缓存Key | 过期时间 | 更新策略 |
|---------|---------|----------|----------|
| Token 黑名单 | token:blacklist:{token} | Token 过期时间 | 登出时添加 |
| 登录失败次数 | login:failed:{username} | 15分钟 | 登录成功时清除 |
| 验证码 | captcha:{captchaId} | 5分钟 | 验证后删除 |
| MFA Secret | mfa:secret:{userId} | 1小时 | MFA 设置时设置 |
| 第三方登录状态 | thirdparty:state:{state} | 10分钟 | 回调后删除 |

### 4.2 缓存注解使用

```java
@Service
public class AuthServiceImpl implements AuthService {
    
    // 缓存用户登录信息
    @Cacheable(value = "loginUser", key = "#userId")
    public LoginUser getLoginUser(Long userId) {
        return authUserMapper.selectByUserId(userId);
    }
    
    // 登出时清除缓存
    @CacheEvict(value = "loginUser", key = "#userId")
    public void logout(Long userId) {
        // ...
    }
}
```

## 5. 安全设计

### 5.1 密码加密

```java
@Configuration
public class SecurityConfig {
    
    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

### 5.2 登录限流

```java
@Component
public class LoginRateLimiter {
    
    private static final int MAX_ATTEMPTS = 5;
    private static final long LOCK_DURATION_MINUTES = 30;
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    public void checkLoginRate(String username) {
        String key = "login:failed:" + username;
        Integer failedCount = (Integer) redisTemplate.opsForValue().get(key);
        
        if (failedCount != null && failedCount >= MAX_ATTEMPTS) {
            Long ttl = redisTemplate.getExpire(key, TimeUnit.MINUTES);
            throw new AuthException("登录失败次数过多，请 " + ttl + " 分钟后再试");
        }
    }
    
    public void recordFailure(String username) {
        String key = "login:failed:" + username;
        redisTemplate.opsForValue().increment(key);
        redisTemplate.expire(key, LOCK_DURATION_MINUTES, TimeUnit.MINUTES);
    }
    
    public void clearFailure(String username) {
        String key = "login:failed:" + username;
        redisTemplate.delete(key);
    }
}
```

### 5.3 Token 安全

```java
@Component
public class TokenSecurityInterceptor implements HandlerInterceptor {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    @Override
    public boolean preHandle(HttpServletRequest request, 
                            HttpServletResponse response, 
                            Object handler) throws Exception {
        String token = request.getHeader("Authorization");
        
        if (token != null && token.startsWith("Bearer ")) {
            token = token.substring(7);
            
            // 检查 Token 是否在黑名单中
            String blacklistKey = "token:blacklist:" + token;
            Boolean isBlacklisted = redisTemplate.hasKey(blacklistKey);
            if (Boolean.TRUE.equals(isBlacklisted)) {
                throw new AuthException("Token 已失效");
            }
        }
        
        return true;
    }
}
```

## 6. 性能优化

### 6.1 数据库优化

#### 索引设计

```sql
-- auth_user 表索引
CREATE INDEX idx_auth_user_username ON auth_user(username);
CREATE INDEX idx_auth_user_phone ON auth_user(phone);
CREATE INDEX idx_auth_user_email ON auth_user(email);

-- auth_device 表索引
CREATE INDEX idx_auth_device_user_id ON auth_device(user_id);
CREATE INDEX idx_auth_device_device_id ON auth_device(device_id);

-- auth_login_log 表索引
CREATE INDEX idx_login_log_user_id ON auth_login_log(user_id);
CREATE INDEX idx_login_log_login_time ON auth_login_log(login_time);

-- auth_third_party 表索引
CREATE INDEX idx_third_party_platform_third_id ON auth_third_party(platform, third_party_id);
CREATE INDEX idx_third_party_user_id ON auth_third_party(user_id);
```

### 6.2 缓存优化

```java
@PostConstruct
public void init() {
    // 预热验证码配置
    preloadCaptchaConfig();
}

private void preloadCaptchaConfig() {
    // 预加载验证码生成器配置
    captchaProducer.getConfig();
}
```

## 7. 监控和日志

### 7.1 登录日志

```java
@Service
public class LoginLogServiceImpl implements LoginLogService {
    
    @Autowired
    private AuthLoginLogMapper loginLogMapper;
    
    @Override
    public void recordLoginLog(Long userId, String username, boolean success, 
                               String ip, String deviceInfo) {
        AuthLoginLog log = new AuthLoginLog();
        log.setUserId(userId);
        log.setUsername(username);
        log.setSuccess(success);
        log.setLoginIp(ip);
        log.setDeviceInfo(deviceInfo);
        log.setLoginTime(new Date());
        
        loginLogMapper.insert(log);
    }
}
```

### 7.2 性能监控

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,tracing
  metrics:
    tags:
      application: qooerp-auth
```

## 8. 部署配置

### 8.1 application.yml

```yaml
server:
  port: 8081

spring:
  application:
    name: qooerp-auth
  
  datasource:
    driver-class-name: org.postgresql.Driver
    url: jdbc:postgresql://localhost:5432/qooerp
    username: postgres
    password: postgres
  
  redis:
    host: localhost
    port: 6379
    database: 1
    password:
  
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: qooerp
      config:
        server-addr: localhost:8848
        namespace: qooerp
        file-extension: yml

# JWT 配置
jwt:
  secret: your-secret-key-change-in-production
  access-token-expiration: 7200  # 2小时
  refresh-token-expiration: 604800  # 7天

# 验证码配置
captcha:
  enabled: true
  length: 4
  expire-seconds: 300

# MFA 配置
mfa:
  enabled: true

# 登录限流配置
login:
  rate-limit:
    max-attempts: 5
    lock-duration: 30  # 分钟

mybatis-plus:
  mapper-locations: classpath*:mapper/**/*.xml
  type-aliases-package: com.qoobot.qooerp.auth.entity
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.slf4j.Slf4jImpl

logging:
  level:
    com.qoobot.qooerp.auth: debug
```

### 8.2 环境变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| SERVER_PORT | 服务端口 | 8081 |
| DB_URL | 数据库URL | - |
| DB_USERNAME | 数据库用户名 | - |
| DB_PASSWORD | 数据库密码 | - |
| REDIS_HOST | Redis主机 | localhost |
| REDIS_PORT | Redis端口 | 6379 |
| NACOS_ADDR | Nacos地址 | localhost:8848 |
| JWT_SECRET | JWT密钥 | - |

## 9. 版本历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0.0 | 20xx-xx-xx | 初始版本，添加前端技术栈 | Auto |
