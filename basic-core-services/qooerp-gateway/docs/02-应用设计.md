# QooERP Gateway 模块 - 应用设计文档

## 1. 应用概述

### 1.1 应用定位
QooERP Gateway 模块是系统的API网关，作为所有外部请求的统一入口，提供路由转发、负载均衡、认证鉴权、限流熔断、日志监控等功能。

### 1.2 应用目标
- 统一API入口，隐藏后端服务细节
- 实现请求路由和负载均衡
- 统一认证和鉴权
- 实现限流熔断保护
- 统一日志监控和追踪
- 实现跨域处理和请求转换

## 2. 应用架构

### 2.1 整体架构

```
                    ┌─────────────┐
                    │   客户端     │
                    │ Web/Mobile  │
                    └──────┬──────┘
                           │
                    ┌──────▼──────┐
                    │  API网关     │
                    │  Gateway    │
                    └──────┬──────┘
                           │
        ┌──────────────────┼──────────────────┐
        │                  │                  │
   ┌────▼────┐      ┌─────▼─────┐      ┌─────▼─────┐
   │认证服务  │      │权限服务    │      │用户服务    │
   │  Auth   │      │Permission │      │   User    │
   └─────────┘      └───────────┘      └───────────┘
        │                  │                  │
   ┌────▼────┐      ┌─────▼─────┐      ┌─────▼─────┐
   │系统服务  │      │组织服务    │      │业务服务    │
   │ System  │      │Organization│      │   ...     │
   └─────────┘      └───────────┘      └───────────┘
```

### 2.2 分层架构

```
qooerp-gateway/
├── controller/                  # 控制器层
│   ├── FallbackController.java  # 熔断降级控制器
│   └── HealthController.java    # 健康检查控制器
├── filter/                      # 过滤器
│   ├── AuthFilter.java          # 认证过滤器
│   ├── LogFilter.java           # 日志过滤器
│   ├── RateLimitFilter.java     # 限流过滤器
│   └── TraceFilter.java         # 链路追踪过滤器
├── handler/                     # 处理器
│   ├── GlobalExceptionHandler.java  # 全局异常处理器
│   └── SentinelFallbackHandler.java  # Sentinel降级处理器
├── config/                      # 配置类
│   ├── GatewayConfig.java       # 网关配置
│   ├── CorsConfig.java          # 跨域配置
│   └── SwaggerConfig.java       # Swagger配置
└── properties/                   # 配置文件
    ├── application.yml
    ├── bootstrap.yml
    └── gateway-routes.yml       # 路由配置
```

## 3. 核心功能设计

### 3.1 路由配置

#### 路由规则

网关路由通过Nacos配置中心动态管理，支持热更新。

```yaml
spring:
  cloud:
    gateway:
      routes:
        # 认证服务路由
        - id: qooerp-auth
          uri: lb://qooerp-auth
          predicates:
            - Path=/api/auth/**
          filters:
            - StripPrefix=2
        
        # 权限服务路由
        - id: qooerp-permission
          uri: lb://qooerp-permission
          predicates:
            - Path=/api/permission/**
          filters:
            - StripPrefix=2
        
        # 用户服务路由
        - id: qooerp-user
          uri: lb://qooerp-user
          predicates:
            - Path=/api/user/**
          filters:
            - StripPrefix=2
        
        # 系统服务路由
        - id: qooerp-system
          uri: lb://qooerp-system
          predicates:
            - Path=/api/system/**
          filters:
            - StripPrefix=2
        
        # 组织服务路由
        - id: qooerp-organization
          uri: lb://qooerp-organization
          predicates:
            - Path=/api/organization/**
          filters:
            - StripPrefix=2
```

#### 路由管理服务

```java
@Service
public class RouteServiceImpl implements RouteService {
    
    @Autowired
    private RouteDefinitionLocator routeDefinitionLocator;
    
    @Autowired
    private RouteDefinitionWriter routeDefinitionWriter;
    
    /**
     * 添加路由
     */
    @Override
    public void addRoute(RouteDefinitionDTO routeDTO) {
        RouteDefinition definition = new RouteDefinition();
        definition.setId(routeDTO.getId());
        definition.setUri(URI.create(routeDTO.getUri()));
        
        // 设置断言
        List<PredicateDefinition> predicates = routeDTO.getPredicates().stream()
            .map(p -> new PredicateDefinition(p))
            .collect(Collectors.toList());
        definition.setPredicates(predicates);
        
        // 设置过滤器
        List<FilterDefinition> filters = routeDTO.getFilters().stream()
            .map(f -> new FilterDefinition(f))
            .collect(Collectors.toList());
        definition.setFilters(filters);
        
        routeDefinitionWriter.save(Mono.just(definition)).subscribe();
    }
    
    /**
     * 删除路由
     */
    @Override
    public void deleteRoute(String routeId) {
        routeDefinitionWriter.delete(Mono.just(routeId)).subscribe();
    }
    
    /**
     * 查询所有路由
     */
    @Override
    public List<RouteDefinitionVO> listRoutes() {
        return routeDefinitionLocator.getRouteDefinitions()
            .map(definition -> {
                RouteDefinitionVO vo = new RouteDefinitionVO();
                vo.setId(definition.getId());
                vo.setUri(definition.getUri().toString());
                vo.setPredicates(definition.getPredicates().stream()
                    .map(PredicateDefinition::toString)
                    .collect(Collectors.toList()));
                vo.setFilters(definition.getFilters().stream()
                    .map(FilterDefinition::toString)
                    .collect(Collectors.toList()));
                return vo;
            })
            .collectList()
            .block();
    }
}
```

### 3.2 认证鉴权

#### 认证过滤器

```java
@Component
@Order(-100)
public class AuthFilter implements GlobalFilter {
    
    @Autowired
    private AuthServiceClient authServiceClient;
    
    private static final String AUTHORIZATION_HEADER = "Authorization";
    private static final String BEARER_PREFIX = "Bearer ";
    
    private static final List<String> WHITE_LIST = Arrays.asList(
        "/api/auth/login",
        "/api/auth/captcha",
        "/api/auth/refresh-token",
        "/api/system/public/**"
    );
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().value();
        
        // 白名单放行
        if (isWhiteList(path)) {
            return chain.filter(exchange);
        }
        
        // 获取Token
        String token = extractToken(request);
        if (StringUtils.isBlank(token)) {
            return unauthorized(exchange, "未登录或token已过期");
        }
        
        // 验证Token
        return authServiceClient.validateToken(token)
            .flatMap(userInfo -> {
                // 添加用户信息到请求头
                ServerHttpRequest modifiedRequest = request.mutate()
                    .header("X-User-Id", String.valueOf(userInfo.getId()))
                    .header("X-Username", userInfo.getUsername())
                    .header("X-User-Name", userInfo.getRealName())
                    .build();
                
                return chain.filter(exchange.mutate().request(modifiedRequest).build());
            })
            .onErrorResume(e -> {
                log.error("Token验证失败: {}", e.getMessage());
                return unauthorized(exchange, "Token验证失败");
            });
    }
    
    private boolean isWhiteList(String path) {
        return WHITE_LIST.stream().anyMatch(path::startsWith);
    }
    
    private String extractToken(ServerHttpRequest request) {
        String authorization = request.getHeaders().getFirst(AUTHORIZATION_HEADER);
        if (StringUtils.isNotBlank(authorization) && authorization.startsWith(BEARER_PREFIX)) {
            return authorization.substring(BEARER_PREFIX.length());
        }
        return null;
    }
    
    private Mono<Void> unauthorized(ServerWebExchange exchange, String message) {
        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 401);
        result.put("message", message);
        result.put("timestamp", System.currentTimeMillis());
        
        DataBuffer buffer = exchange.getResponse().bufferFactory()
            .wrap(JsonUtils.toJsonBytes(result));
        
        return exchange.getResponse().writeWith(Mono.just(buffer));
    }
}
```

#### 权限过滤器

```java
@Component
@Order(-99)
public class PermissionFilter implements GlobalFilter {
    
    @Autowired
    private PermissionServiceClient permissionServiceClient;
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        ServerHttpRequest request = exchange.getRequest();
        String path = request.getPath().value();
        String method = request.getMethod().name();
        
        // 获取用户ID
        String userId = request.getHeaders().getFirst("X-User-Id");
        if (StringUtils.isBlank(userId)) {
            return chain.filter(exchange);
        }
        
        // 获取需要的权限
        String requiredPermission = extractRequiredPermission(path, method);
        if (StringUtils.isBlank(requiredPermission)) {
            return chain.filter(exchange);
        }
        
        // 验证权限
        return permissionServiceClient.hasPermission(Long.parseLong(userId), requiredPermission)
            .flatMap(hasPermission -> {
                if (hasPermission) {
                    return chain.filter(exchange);
                } else {
                    return forbidden(exchange, "权限不足");
                }
            })
            .onErrorResume(e -> {
                log.error("权限验证失败: {}", e.getMessage());
                return forbidden(exchange, "权限验证失败");
            });
    }
    
    private String extractRequiredPermission(String path, String method) {
        // 根据路径和方法提取需要的权限
        // 例如: /api/user -> user:*
        // 例如: POST /api/user -> user:create
        String resourcePath = path.substring(5); // 去掉 /api/
        String resource = resourcePath.split("/")[0];
        
        switch (method.toUpperCase()) {
            case "GET":
                return resource + ":query";
            case "POST":
                return resource + ":create";
            case "PUT":
                return resource + ":update";
            case "DELETE":
                return resource + ":delete";
            default:
                return resource + ":*";
        }
    }
    
    private Mono<Void> forbidden(ServerWebExchange exchange, String message) {
        exchange.getResponse().setStatusCode(HttpStatus.FORBIDDEN);
        exchange.getResponse().getHeaders().setContentType(MediaType.APPLICATION_JSON);
        
        Map<String, Object> result = new HashMap<>();
        result.put("code", 403);
        result.put("message", message);
        result.put("timestamp", System.currentTimeMillis());
        
        DataBuffer buffer = exchange.getResponse().bufferFactory()
            .wrap(JsonUtils.toJsonBytes(result));
        
        return exchange.getResponse().writeWith(Mono.just(buffer));
    }
}
```

### 3.3 限流熔断

#### 限流配置

```yaml
spring:
  cloud:
    gateway:
      routes:
        - id: qooerp-auth
          uri: lb://qooerp-auth
          predicates:
            - Path=/api/auth/**
          filters:
            - name: RequestRateLimiter
              args:
                redis-rate-limiter.replenishRate: 100  # 每秒补充令牌数
                redis-rate-limiter.burstCapacity: 200  # 令牌桶容量
                key-resolver: "#{@ipKeyResolver}"  # IP限流
            - StripPrefix=2

# Sentinel限流配置
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8080
      datasource:
        ds:
          nacos:
            server-addr: localhost:8848
            namespace: qooerp
            data-id: gateway-sentinel-rules
            group-id: DEFAULT_GROUP
            rule-type: flow
```

#### IP限流解析器

```java
@Component
public class IpKeyResolver implements KeyResolver {
    
    @Override
    public Mono<String> resolve(ServerWebExchange exchange) {
        String ip = getIpAddress(exchange.getRequest());
        return Mono.just(ip);
    }
    
    private String getIpAddress(ServerHttpRequest request) {
        String ip = request.getHeaders().getFirst("X-Forwarded-For");
        if (ip == null | ip.isEmpty() | "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeaders().getFirst("X-Real-IP");
        }
        if (ip == null | ip.isEmpty() | "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddress() != null ? 
                  request.getRemoteAddress().getAddress().getHostAddress() : "";
        }
        return ip;
    }
}
```

#### Sentinel降级处理器

```java
@Component
public class SentinelFallbackHandler implements BlockRequestHandler {
    
    @Override
    public Mono<ServerResponse> handleRequest(ServerWebExchange exchange, Throwable ex) {
        Map<String, Object> result = new HashMap<>();
        
        if (ex instanceof FlowException) {
            result.put("code", 429);
            result.put("message", "访问过于频繁，请稍后再试");
        } else if (ex instanceof DegradeException) {
            result.put("code", 503);
            result.put("message", "服务暂时不可用，请稍后再试");
        } else if (ex instanceof ParamFlowException) {
            result.put("code", 400);
            result.put("message", "请求参数不合法");
        } else {
            result.put("code", 500);
            result.put("message", "系统繁忙，请稍后再试");
        }
        
        result.put("timestamp", System.currentTimeMillis());
        
        return ServerResponse.status(HttpStatus.OK)
            .contentType(MediaType.APPLICATION_JSON)
            .body(BodyInserters.fromValue(result));
    }
}
```

### 3.4 日志监控

#### 日志过滤器

```java
@Component
@Order(-90)
public class LogFilter implements GlobalFilter {
    
    private static final String START_TIME = "startTime";
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, GatewayFilterChain chain) {
        exchange.getAttributes().put(START_TIME, System.currentTimeMillis());
        
        return chain.filter(exchange).then(Mono.fromRunnable(() -> {
            ServerHttpRequest request = exchange.getRequest();
            ServerHttpResponse response = exchange.getResponse();
            
            Long startTime = exchange.getAttribute(START_TIME);
            Long executeTime = System.currentTimeMillis() - startTime;
            
            // 构建日志信息
            Map<String, Object> logInfo = new HashMap<>();
            logInfo.put("traceId", MDC.get("traceId"));
            logInfo.put("method", request.getMethod().name());
            logInfo.put("path", request.getPath().value());
            logInfo.put("remoteAddr", getIpAddress(request));
            logInfo.put("userAgent", request.getHeaders().getFirst("User-Agent"));
            logInfo.put("userId", request.getHeaders().getFirst("X-User-Id"));
            logInfo.put("statusCode", response.getStatusCode() != null ? 
                        response.getStatusCode().value() : null);
            logInfo.put("executeTime", executeTime);
            
            // 记录日志
            log.info("Gateway Request: {}", JsonUtils.toJson(logInfo));
            
            // 记录慢请求
            if (executeTime > 3000) {
                log.warn("Slow Request: {}ms - {}", executeTime, request.getPath().value());
            }
        }));
    }
    
    private String getIpAddress(ServerHttpRequest request) {
        String ip = request.getHeaders().getFirst("X-Forwarded-For");
        if (ip == null | ip.isEmpty() | "unknown".equalsIgnoreCase(ip)) {
            ip = request.getHeaders().getFirst("X-Real-IP");
        }
        if (ip == null | ip.isEmpty() | "unknown".equalsIgnoreCase(ip)) {
            ip = request.getRemoteAddress() != null ? 
                  request.getRemoteAddress().getAddress().getHostAddress() : "";
        }
        return ip;
    }
}
```

## 4. 配置管理

### 4.1 跨域配置

```java
@Configuration
public class CorsConfig {
    
    @Bean
    public CorsWebFilter corsFilter() {
        CorsConfiguration config = new CorsConfiguration();
        
        // 允许的源
        config.addAllowedOriginPattern("*");
        
        // 允许的头
        config.addAllowedHeader("*");
        
        // 允许的方法
        config.addAllowedMethod("*");
        
        // 允许携带凭证
        config.setAllowCredentials(true);
        
        // 暴露的头
        config.addExposedHeader("Authorization");
        config.addExposedHeader("X-User-Id");
        config.addExposedHeader("X-Username");
        
        // 预检请求的有效期
        config.setMaxAge(3600L);
        
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", config);
        
        return new CorsWebFilter(source);
    }
}
```

### 4.2 全局异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    /**
     * 网关异常
     */
    @ExceptionHandler(Exception.class)
    public Response<?> handleException(Exception ex) {
        log.error("网关异常: {}", ex.getMessage(), ex);
        
        if (ex instanceof TimeoutException) {
            return Response.error(504, "请求超时");
        } else if (ex instanceof ConnectException) {
            return Response.error(503, "服务连接失败");
        } else {
            return Response.error(500, "系统繁忙，请稍后再试");
        }
    }
}
```

## 5. 监控和追踪

### 5.1 链路追踪

```yaml
management:
  otlp:
    tracing:
      endpoint: ${OTEL_ENDPOINT:http://localhost:4318/v1/traces}
  tracing:
    sampling:
      probability: 1.0  # 采样率
    propagation:
      type: w3c
```

### 5.2 健康检查

```java
@RestController
@RequestMapping("/actuator")
public class HealthController {
    
    @Autowired
    private NacosServiceManager nacosServiceManager;
    
    @GetMapping("/health")
    public Response<HealthInfo> health() {
        HealthInfo healthInfo = new HealthInfo();
        healthInfo.setStatus("UP");
        healthInfo.setTimestamp(System.currentTimeMillis());
        
        // 检查Nacos连接
        try {
            nacosServiceManager.getNamingService().getServerStatus();
            healthInfo.setNacosStatus("UP");
        } catch (Exception e) {
            healthInfo.setNacosStatus("DOWN");
        }
        
        return Response.success(healthInfo);
    }
}
```

## 6. 接口设计

### 6.1 路由管理接口

```
POST   /api/gateway/route                # 添加路由
GET    /api/gateway/route/list            # 查询所有路由
DELETE /api/gateway/route/{id}            # 删除路由
PUT    /api/gateway/route/{id}            # 更新路由
```

### 6.2 监控接口

```
GET    /actuator/health                   # 健康检查
GET    /actuator/gateway/routes           # 查看路由
GET    /actuator/gateway/globalfilters    # 查看全局过滤器
GET    /actuator/gateway/routefilters     # 查看路由过滤器
```

## 7. 部署配置

### 7.1 application.yml

```yaml
server:
  port: 8080

spring:
  application:
    name: qooerp-gateway
  
  cloud:
    nacos:
      discovery:
        server-addr: localhost:8848
        namespace: qooerp
      config:
        server-addr: localhost:8848
        namespace: qooerp
        file-extension: yml
        group-id: GATEWAY_GROUP
    
    gateway:
      discovery:
        locator:
          enabled: true
          lower-case-service-id: true
      # 路由配置在Nacos中管理
      
      # 全局跨域配置
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOriginPatterns: "*"
            allowedMethods: "*"
            allowedHeaders: "*"
            allowCredentials: true
            maxAge: 3600

# Redis配置（用于限流）
spring:
  redis:
    host: localhost
    port: 6379
    database: 0
    password:

# Sentinel配置
spring:
  cloud:
    sentinel:
      transport:
        dashboard: localhost:8848  # Sentinel控制台地址
        port: 8719                    # 客户端API端口
      eager: true                    # 服务启动时立即注册到Sentinel

# 日志配置
logging:
  level:
    root: INFO
    com.qoobot.qooerp.gateway: DEBUG
    org.springframework.cloud.gateway: DEBUG
  pattern:
    console: "%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level [%X{traceId}] %logger{36} - %msg%n"
```

### 7.2 环境变量

| 变量名 | 说明 | 默认值 |
|--------|------|--------|
| SERVER_PORT | 服务端口 | 8080 |
| NACOS_ADDR | Nacos地址 | localhost:8848 |
| REDIS_HOST | Redis主机 | localhost |
| REDIS_PORT | Redis端口 | 6379 |
| SENTINEL_DASHBOARD | Sentinel控制台 | localhost:8848 |

## 8. 版本历史

| 版本 | 日期 | 变更内容 | 作者 |
|------|------|----------|------|
| 1.0.0 | 2025-01-17 | 初始版本 | Auto |
